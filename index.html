<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aplicativo de Produtividade e Colaboração</title>
    <!-- Inclui a fonte Inter -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <!-- Inclui Tailwind CSS para estilização rápida -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inclui Font Awesome para ícones -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Altera o layout principal para usar Flexbox e permitir redimensionamento */
        .flex-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Estiliza o canvas do mapa mental */
        #mindMapCanvas {
            background-color: #f8f9fa;
            cursor: grab;
            border-right: 1px solid #e2e8f0;
        }
        #mindMapCanvas.grabbing {
            cursor: grabbing;
        }

        /* Estiliza o botão de redimensionamento */
        #resizeHandle {
            width: 10px;
            cursor: col-resize;
            background-color: #e2e8f0;
            border-left: 1px solid #cbd5e1;
            border-right: 1px solid #cbd5e1;
            transition: background-color 0.2s;
        }
        #resizeHandle:hover {
            background-color: #cbd5e1;
        }

        /* Estiliza os botões da barra de ferramentas */
        .toolbar-btn {
            @apply p-2 rounded-md transition-colors duration-200 hover:bg-gray-200;
        }
        .toolbar-btn i {
            @apply text-gray-600;
        }
        /* Estiliza o editor de notas */
        #notesEditor {
            @apply bg-white p-6 overflow-y-auto transition-all duration-300 ease-in-out;
        }
        #notesEditor.hidden {
            display: none;
        }
        /* Estiliza a área de conteúdo do editor WYSIWYG */
        #noteContent {
            @apply w-full p-4 border rounded-lg resize-none min-h-[300px] outline-none focus:ring-2 focus:ring-blue-500;
        }
        /* Estiliza os botões do editor de notas */
        .notes-toolbar-btn {
            @apply p-2 rounded-md transition-colors duration-200 hover:bg-gray-200;
        }
        .notes-toolbar-btn i {
            @apply text-gray-600;
        }
        /* Define a classe para o nó selecionado no canvas */
        .selected-node {
            animation: pulse-border 1s infinite alternate;
        }

        /* Animação para o pulso do nó */
        @keyframes pulse-border {
            from {
                filter: drop-shadow(0 0 2px rgba(59, 130, 246, 0.5));
            }
            to {
                filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.8));
            }
        }
        
        /* Estilização da Pop-up */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }

        .modal-content {
            @apply bg-white p-8 rounded-lg shadow-xl max-w-sm w-full;
            background: #fff;
            padding: 20px;
            border-radius: 6px;
        }
        /* Estilização para os botões de tema */
        .theme-btn {
            @apply w-full text-left py-2 px-4 rounded-md transition-colors duration-200 hover:bg-gray-100;
        }
        .color-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            border: 1px solid rgba(0,0,0,0.1);
        }

        /* Estilização do seletor de cores individual */
        #individualColorPickerModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 60;
        }

        #individualColorPickerModal.active {
            display: flex;
        }

        .color-picker-content {
            @apply bg-white p-6 rounded-lg shadow-xl w-80;
            background: #fff;
    padding: 20px;
    border-radius: 6px;
        }

        #colorPickerArea {
            position: relative;
            width: 100%;
            padding-top: 100%; /* Proporção 1:1 */
            background: hsl(0, 100%, 50%);
        }

        #colorPickerSelector {
            position: absolute;
            width: 10px;
            height: 10px;
            border: 1px solid white;
            border-radius: 50%;
            box-shadow: 0 0 0 1px black, inset 0 0 0 1px black;
            cursor: pointer;
            transform: translate(-50%, -50%);
        }

        .color-picker-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #whiteOverlay {
            background: linear-gradient(to right, white, rgba(255, 255, 255, 0));
        }

        #blackOverlay {
            background: linear-gradient(to top, black, rgba(0, 0, 0, 0));
        }

        #hueSlider {
            width: 100%;
            height: 10px;
            background: linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00);
            border-radius: 5px;
            appearance: none;
            cursor: pointer;
        }

        #hueSlider::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: white;
            border: 1px solid black;
        }

        #selectedColorPreview {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="flex-container">
        <!-- Editor de Mapas Mentais (Coluna Esquerda) -->
        <div id="mindMapContainer" class="relative flex flex-col h-full bg-white shadow-lg rounded-r-xl" style="width: 60%;">
            <!-- Barra de Ferramentas Superior -->
            <div class="p-4 flex items-center justify-between border-b bg-gray-50">
                <div class="flex space-x-2">
                    <button id="undoMindMapBtn" class="toolbar-btn" title="Desfazer (Ctrl + Z)"><i class="fa-solid fa-rotate-left"></i></button>
                    <button id="redoMindMapBtn" class="toolbar-btn" title="Refazer (Ctrl + Y)"><i class="fa-solid fa-rotate-right"></i></button>
                    <button id="addNodeBtn" class="toolbar-btn" title="Adicionar Novo Nó (TAB)"><i class="fa-solid fa-plus"></i></button>
                    <button id="layoutBtn" class="toolbar-btn" title="Opções de Layout"><i class="fa-solid fa-diagram-project"></i></button>
                    <!-- Dropdown com temas de cores -->
                    <div class="relative">
                        <button id="colorPaletteBtn" class="toolbar-btn" title="Paleta de Cores"><i class="fa-solid fa-palette"></i></button>
                        <div id="colorPicker" class="absolute top-12 left-0 p-2 bg-white rounded-lg shadow-xl border hidden">
                            <div class="flex flex-col space-y-2">
                                <button class="theme-btn" data-theme="vermelho"><span class="color-circle" style="background-color: #bb0e0e;"></span></button>
                                <button class="theme-btn" data-theme="azul"><span class="color-circle" style="background-color: #1e3a8a;"></span></button>
                                <button class="theme-btn" data-theme="verde"><span class="color-circle" style="background-color: #166534;"></span></button>
                                <button class="theme-btn" data-theme="roxo"><span class="color-circle" style="background-color: #4c1d95;"></span></button>
                                <button class="theme-btn" data-theme="cinza"><span class="color-circle" style="background-color: #3f3f46;"></span></button>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="flex space-x-2">
                    <button id="newProjectBtn" class="toolbar-btn" title="Novo Projeto"><i class="fa-solid fa-file-circle-plus"></i></button>
                    <button id="saveProjectBtn" class="toolbar-btn" title="Salvar Projeto"><i class="fa-solid fa-download"></i></button>
                    <!-- Input de arquivo oculto para carregar o projeto -->
                    <input type="file" id="loadFileInput" accept=".json" class="hidden">
                    <button id="loadProjectBtn" class="toolbar-btn" title="Carregar Projeto"><i class="fa-solid fa-upload"></i></button>
                </div>
            </div>

            <!-- Canvas do Mapa Mental -->
            <canvas id="mindMapCanvas" class="flex-grow"></canvas>

            <!-- Controles de Navegação do Canvas (Canto Inferior Direito) -->
            <div class="absolute bottom-4 right-4 flex flex-col space-y-2">
                <button id="zoomInBtn" class="toolbar-btn shadow-md"><i class="fa-solid fa-plus"></i></button>
                <button id="zoomOutBtn" class="toolbar-btn shadow-md"><i class="fa-solid fa-minus"></i></button>
                <button id="recenterBtn" class="toolbar-btn shadow-md"><i class="fa-solid fa-expand"></i></button>
            </div>
        </div>

        <!-- Botão de redimensionamento (o novo elemento) -->
        <div id="resizeHandle"></div>

        <!-- Editor de Notas (Coluna Direita) -->
        <div id="notesEditor" class="hidden flex flex-col h-full bg-white shadow-xl" style="width: 40%;">
            <!-- Barra de Ferramentas do Editor de Notas -->
            <div class="flex items-center justify-between p-4 border-b bg-gray-50">
                <input id="noteTitle" type="text" placeholder="Título da Nota" class="flex-grow text-lg font-semibold bg-transparent border-none outline-none focus:ring-0">
                <div class="flex space-x-2">
                    <button id="closeNotesBtn" class="notes-toolbar-btn" title="Fechar"><i class="fa-solid fa-xmark"></i></button>
                </div>
            </div>
            <div class="flex items-center space-x-2 p-4 border-b bg-gray-50">
                <button class="notes-toolbar-btn" onclick="formatDoc('bold')" title="Negrito"><i class="fa-solid fa-bold"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('italic')" title="Itálico"><i class="fa-solid fa-italic"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('underline')" title="Sublinhado"><i class="fa-solid fa-underline"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('strikeThrough')" title="Tachado"><i class="fa-solid fa-strikethrough"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('justifyLeft')" title="Alinhar à Esquerda"><i class="fa-solid fa-align-left"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('justifyCenter')" title="Alinhar ao Centro"><i class="fa-solid fa-align-center"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('justifyRight')" title="Alinhar à Direita"><i class="fa-solid fa-align-right"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('insertUnorderedList')" title="Lista com Marcadores"><i class="fa-solid fa-list-ul"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('insertOrderedList')" title="Lista Numerada"><i class="fa-solid fa-list-ol"></i></button>
                <select onchange="formatDoc('formatBlock', this.value)" class="p-1 rounded-md bg-white border">
                    <option value="p">Parágrafo</option>
                    <option value="h1">Título 1</option>
                    <option value="h2">Título 2</option>
                </select>
                <!-- NOVO: Botão para abrir o seletor de cor individual -->
                <button id="individualColorBtn" class="notes-toolbar-btn" title="Alterar Cor do Nó"><i class="fa-solid fa-fill-drip"></i></button>
            </div>
            
            <!-- Conteúdo do Editor de Notas (WYSIWYG) -->
            <div id="noteContent" contenteditable="true" class="flex-grow p-6 outline-none focus:ring-0"></div>
        </div>
    </div>

    <!-- Pop-up de Novo Projeto (oculto por padrão) -->
    <div id="newProjectModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold">Novo Projeto</h3>
                <button id="closeModalBtn" class="text-gray-500 hover:text-gray-800"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <p class="mb-6 text-gray-700">Tem certeza que deseja criar um novo projeto e apagar o arquivo atual?</p>
            <div class="flex justify-end space-x-4">
                <button id="confirmNewProjectBtn" class="bg-red-500 text-white font-bold py-2 px-4 rounded-md hover:bg-red-600 transition-colors duration-200">Sim</button>
                <button id="cancelNewProjectBtn" class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-md hover:bg-gray-300 transition-colors duration-200">Não</button>
            </div>
        </div>
    </div>

    <!-- NOVO: Pop-up do seletor de cor individual -->
    <div id="individualColorPickerModal">
        <div class="color-picker-content">
            <div class="flex justify-between items-center mb-4">
                <h4 class="text-lg font-semibold">Escolher Cor do Nó</h4>
                <button id="closeIndividualColorPicker" class="text-gray-500 hover:text-gray-800"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div id="colorPickerArea" class="relative mb-4 cursor-crosshair">
                <div id="whiteOverlay" class="color-picker-overlay"></div>
                <div id="blackOverlay" class="color-picker-overlay"></div>
                <div id="colorPickerSelector"></div>
            </div>
            <input type="range" id="hueSlider" class="w-full mb-4" min="0" max="360" value="0">
            <div class="flex items-center space-x-2">
                <span id="selectedColorPreview" class="block w-6 h-6 rounded-full border border-gray-300"></span>
                <input type="text" id="hexInput" class="w-full border rounded-md p-2 text-sm font-mono" placeholder="#000000">
            </div>
        </div>
    </div>

    <script>
        // Variáveis globais para o canvas e o contexto
        const canvas = document.getElementById('mindMapCanvas');
        const ctx = canvas.getContext('2d');
        const mindMapContainer = document.getElementById('mindMapContainer');
        const notesEditor = document.getElementById('notesEditor');
        const noteTitleInput = document.getElementById('noteTitle');
        const noteContentDiv = document.getElementById('noteContent');
        const colorPaletteBtn = document.getElementById('colorPaletteBtn');
        const colorPicker = document.getElementById('colorPicker');

        // Estado do aplicativo
        let nodes = [];
        let selectedNodeId = null;
        let scale = 1.0;
        let originX = 0;
        let originY = 0;
        let isCanvasDragging = false; 
        let isNodeDragging = false;
        let draggedNode = null;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Histórico para Desfazer/Refazer
        const history = [];
        let historyIndex = -1;

        // NOVO: Temas de cores para os nós
        const colorThemes = {
            'vermelho': ['#bb0e0e', '#8d0000', '#733232', '#582424', '#451b1b'],
            'azul': ['#1e3a8a', '#172554', '#3b82f6', '#93c5fd', '#bfdbfe'],
            'verde': ['#166534', '#064e3b', '#047857', '#34d399', '#6ee7b7'],
            'roxo': ['#4c1d95', '#3b0764', '#5b21b6', '#a78bfa', '#c4b5fd'],
            'cinza': ['#3f3f46', '#27272a', '#52525b', '#a1a1aa', '#d4d4d8']
        };
        let currentTheme = 'azul';

        // Objeto de dados simulado (seria armazenado em um banco de dados real)
        let appData = {
            nodes: [
                { id: 'root', parentId: null, text: 'Ideia Central', x: 0, y: 0, color: colorThemes[currentTheme][0], note: 'Esta é a nota para o nó central.' },
            ],
            notes: {
                'root': '<h1>Bem-vindo!</h1><p>Esta é a nota principal. Clique em um nó para editar seu conteúdo.</p>'
            },
            selectedNodeId: null,
            scale: 1.0,
            originX: 0,
            originY: 0
        };

        // Função para salvar o estado atual
        function saveState() {
            if (historyIndex < history.length - 1) {
                history.splice(historyIndex + 1);
            }
            history.push(JSON.stringify({ nodes: nodes, notes: appData.notes }));
            historyIndex++;
        }

        // Função para carregar um estado do histórico
        function loadState(index) {
            if (index >= 0 && index < history.length) {
                const state = JSON.parse(history[index]);
                nodes = state.nodes;
                appData.notes = state.notes;
                redrawCanvas();
            }
        }
        
        // --- FUNÇÕES DE UNDO/REDO CENTRALIZADAS ---
        function undoAction() {
            if (historyIndex > 0) {
                historyIndex--;
                loadState(historyIndex);
            }
        }

        function redoAction() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadState(historyIndex);
            }
        }

        // Event listeners para Desfazer/Refazer no mapa mental
        document.getElementById('undoMindMapBtn').addEventListener('click', undoAction);
        document.getElementById('redoMindMapBtn').addEventListener('click', redoAction);
        
        // --- FUNÇÕES DE SALVAR E CARREGAR PROJETO ---
        
        // Salva o projeto como um arquivo .json
        function saveProject() {
            const projectData = {
                nodes: nodes,
                notes: appData.notes
            };
            const dataStr = JSON.stringify(projectData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'projeto-mapa-mental.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Carrega um projeto de um arquivo .json
        function loadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    if (loadedData.nodes && loadedData.notes) {
                        nodes = loadedData.nodes;
                        appData.notes = loadedData.notes;
                        selectedNodeId = null;
                        notesEditor.classList.add('hidden');
                        
                        // Limpa o histórico e salva o novo estado
                        history.length = 0;
                        historyIndex = -1;
                        saveState();

                        // Posiciona a câmera para exibir o nó central após o carregamento
                        const rootNode = nodes.find(n => n.id === 'root');
                        if (rootNode) {
                            originX = (canvas.width / 2) - rootNode.x;
                            originY = (canvas.height / 2) - rootNode.y;
                        } else {
                            // Se não houver nó central, centraliza no ponto (0,0)
                            originX = 0;
                            originY = 0;
                        }
                        scale = 1.0;
                        
                        redrawCanvas();
                    } else {
                        console.error('Formato do arquivo JSON inválido.');
                    }
                } catch (error) {
                    console.error('Erro ao analisar o arquivo JSON:', error);
                }
            };
            reader.readAsText(file);
        }

        // --- LÓGICA DO NOVO PROJETO (POP-UP) ---

        const newProjectModal = document.getElementById('newProjectModal');
        const newProjectBtn = document.getElementById('newProjectBtn');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const confirmNewProjectBtn = document.getElementById('confirmNewProjectBtn');
        const cancelNewProjectBtn = document.getElementById('cancelNewProjectBtn');

        // Mostra a pop-up
        newProjectBtn.addEventListener('click', () => {
            newProjectModal.classList.remove('hidden');
        });

        // Esconde a pop-up
        function hideModal() {
            newProjectModal.classList.add('hidden');
        }

        closeModalBtn.addEventListener('click', hideModal);
        cancelNewProjectBtn.addEventListener('click', hideModal);
        
        // Reseta o projeto para o estado inicial
        confirmNewProjectBtn.addEventListener('click', () => {
            nodes = [
                { id: 'root', parentId: null, text: 'Ideia Central', x: 0, y: 0, color: colorThemes[currentTheme][0], note: 'Esta é a nota para o nó central.' },
            ];
            appData.notes = {
                'root': '<h1>Bem-vindo!</h1><p>Esta é a nota principal. Clique em um nó para editar seu conteúdo.</p>'
            };
            
            history.length = 0;
            historyIndex = -1;
            saveState();

            selectedNodeId = null;
            notesEditor.classList.add('hidden');
            
            originX = 0;
            originY = 0;
            scale = 1.0;

            redrawCanvas();
            hideModal();
        });


        // --- NOVO: LÓGICA DO SELETOR DE COR INDIVIDUAL ---
        const individualColorBtn = document.getElementById('individualColorBtn');
        const individualColorPickerModal = document.getElementById('individualColorPickerModal');
        const closeIndividualColorPickerBtn = document.getElementById('closeIndividualColorPicker');
        const colorPickerArea = document.getElementById('colorPickerArea');
        const colorPickerSelector = document.getElementById('colorPickerSelector');
        const hueSlider = document.getElementById('hueSlider');
        const selectedColorPreview = document.getElementById('selectedColorPreview');
        const hexInput = document.getElementById('hexInput');

        let isPickingColor = false;
        let currentHue = 0;
        let currentSaturation = 100;
        let currentLightness = 50;

        function updateColorFromPicker(e) {
            const rect = colorPickerArea.getBoundingClientRect();
            const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
            const y = Math.max(0, Math.min(e.clientY - rect.top, rect.height));

            currentSaturation = (x / rect.width) * 100;
            currentLightness = 100 - (y / rect.height) * 100;

            updateSelectedColor();
        }

        function updateSelectedColor() {
            const newColor = `hsl(${currentHue}, ${currentSaturation}%, ${currentLightness}%)`;
            const hexColor = hslToHex(currentHue, currentSaturation, currentLightness);
            
            selectedColorPreview.style.backgroundColor = newColor;
            hexInput.value = hexColor;

            if (selectedNodeId) {
                const node = nodes.find(n => n.id === selectedNodeId);
                if (node) {
                    node.color = hexColor;
                    redrawCanvas();
                }
            }
        }
        
        // Converte HSL para Hex (simplificado para o exemplo)
        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }
        
        // Atualiza o seletor de cor no gradiente
        function updateColorSelectorPosition() {
            const rect = colorPickerArea.getBoundingClientRect();
            const x = (currentSaturation / 100) * rect.width;
            const y = (1 - currentLightness / 100) * rect.height;
            colorPickerSelector.style.left = `${x}px`;
            colorPickerSelector.style.top = `${y}px`;
        }

        individualColorBtn.addEventListener('click', () => {
            if (selectedNodeId) {
                individualColorPickerModal.classList.add('active');
            }
        });

        closeIndividualColorPickerBtn.addEventListener('click', () => {
            individualColorPickerModal.classList.remove('active');
            saveState(); // Salva o estado ao fechar o seletor
        });

        colorPickerArea.addEventListener('mousedown', (e) => {
            isPickingColor = true;
            updateColorFromPicker(e);
            updateColorSelectorPosition();
        });

        document.addEventListener('mousemove', (e) => {
            if (isPickingColor) {
                updateColorFromPicker(e);
                updateColorSelectorPosition();
            }
        });

        document.addEventListener('mouseup', () => {
            isPickingColor = false;
        });

        hueSlider.addEventListener('input', (e) => {
            currentHue = e.target.value;
            colorPickerArea.style.backgroundColor = `hsl(${currentHue}, 100%, 50%)`;
            updateSelectedColor();
        });

        hexInput.addEventListener('change', (e) => {
            const hex = e.target.value;
            // Converte hex para HSL e atualiza os seletores e o nó
            // Implementação simplificada: apenas atualiza a cor do nó
            if (selectedNodeId) {
                const node = nodes.find(n => n.id === selectedNodeId);
                if (node) {
                    node.color = hex;
                    redrawCanvas();
                    saveState();
                }
            }
        });
        // FIM: LÓGICA DO SELETOR DE COR INDIVIDUAL

        function init() {
            nodes = appData.nodes;
            saveState();
            setupCanvas();
            setupResizing(); // Configura o redimensionamento
            window.addEventListener('resize', () => {
                resizeCanvas();
                redrawCanvas();
            });
            noteContentDiv.addEventListener('input', saveNoteContent);
            noteTitleInput.addEventListener('input', saveNodeTitle);
            document.getElementById('closeNotesBtn').addEventListener('click', () => {
                notesEditor.classList.add('hidden');
                selectedNodeId = null;
                redrawCanvas();
            });
            document.getElementById('addNodeBtn').addEventListener('click', addNode);
            document.getElementById('zoomInBtn').addEventListener('click', () => {
                scale *= 1.1;
                redrawCanvas();
            });
            document.getElementById('zoomOutBtn').addEventListener('click', () => {
                scale /= 1.1;
                redrawCanvas();
            });
            document.getElementById('recenterBtn').addEventListener('click', () => {
                originX = 0;
                originY = 0;
                scale = 1.0;
                redrawCanvas();
            });
            
            // Listener para aplicar temas
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const themeButton = e.target.closest('.theme-btn');
                    if (themeButton) {
                        const themeName = themeButton.dataset.theme;
                        currentTheme = themeName;
                        applyThemeToNodes();
                    }
                });
            });

            // Event listeners para os novos botões
            document.getElementById('saveProjectBtn').addEventListener('click', saveProject);
            document.getElementById('loadProjectBtn').addEventListener('click', () => {
                document.getElementById('loadFileInput').click();
            });
            document.getElementById('loadFileInput').addEventListener('change', loadProject);
            
            // Event listener para atalhos de teclado com verificação de foco
            document.addEventListener('keydown', (e) => {
                // Checa se o elemento focado é o editor de notas
                if (document.activeElement === noteContentDiv || document.activeElement === noteTitleInput) {
                    return; // Sai da função se o foco estiver no editor de notas para não ativar os atalhos
                }

                // Previne o comportamento padrão do navegador para evitar conflitos
                if (e.key === 'Tab' || e.key === 'Enter' || (e.ctrlKey && (e.key === 'z' || e.key === 'y'))) {
                    e.preventDefault();
                }

                // A maioria dos atalhos requer um nó selecionado
                if (!selectedNodeId) {
                    if (e.key === 'Tab') {
                        addNode(); // Permite adicionar um nó sub-nó mesmo sem seleção
                    }
                    return;
                }

                switch(e.key) {
                    case 'Tab': // Adicionar sub-nó
                        addNode();
                        break;
                    case 'Enter': // Adicionar nó irmão
                        addSiblingNode();
                        break;
                    case 'Delete':
                    case 'Backspace': // Excluir nó
                        deleteNode();
                        break;
                    case 'z': // Desfazer
                        if (e.ctrlKey) {
                            undoAction();
                        }
                        break;
                    case 'y': // Refazer
                        if (e.ctrlKey) {
                            redoAction();
                        }
                        break;
                }
            });

            // Lógica de clique para mostrar/esconder o dropdown
            document.addEventListener('click', (e) => {
                const target = e.target;
                if (target === colorPaletteBtn || colorPaletteBtn.contains(target)) {
                    colorPicker.classList.toggle('hidden');
                } else if (!colorPicker.contains(target)) {
                    colorPicker.classList.add('hidden');
                }
            });

            resizeCanvas();
            redrawCanvas();
        }

        // Função para obter a profundidade de um nó
        function getNodeDepth(nodeId) {
            let depth = 0;
            let node = nodes.find(n => n.id === nodeId);
            while (node && node.parentId !== null) {
                node = nodes.find(n => n.id === node.parentId);
                depth++;
            }
            return depth;
        }

        // Função para aplicar o tema de cores aos nós
        function applyThemeToNodes() {
            const themeColors = colorThemes[currentTheme];
            nodes.forEach(node => {
                const depth = getNodeDepth(node.id);
                // Usa a cor correspondente à profundidade ou a última cor do tema como fallback
                node.color = themeColors[depth] || themeColors[themeColors.length - 1];
            });
            saveState();
            redrawCanvas();
        }


        // Função para adicionar nó irmão
        function addSiblingNode() {
            if (!selectedNodeId) return;
            const selectedNode = nodes.find(n => n.id === selectedNodeId);
            if (!selectedNode || !selectedNode.parentId) return;

            const parentNode = nodes.find(n => n.id === selectedNode.parentId);
            if (!parentNode) return;
            
            const depth = getNodeDepth(selectedNode.id);

            const newNodeId = `node-${Date.now()}`;
            const newNode = {
                id: newNodeId,
                parentId: selectedNode.parentId,
                text: 'Novo Nó',
                x: selectedNode.x,
                y: selectedNode.y + 150, // Posição abaixo do nó irmão
                color: colorThemes[currentTheme][depth] || colorThemes[currentTheme][colorThemes.length - 1],
                note: ''
            };
            nodes.push(newNode);
            appData.notes[newNodeId] = '';
            
            saveState();
            redrawCanvas();
        }

        // Função para excluir nó
        function deleteNode() {
            if (!selectedNodeId) return;
            // Impede a exclusão do nó raiz
            if (selectedNodeId === 'root') return;

            const indexToDelete = nodes.findIndex(n => n.id === selectedNodeId);
            if (indexToDelete === -1) return;

            // Remove o nó e sua nota
            nodes.splice(indexToDelete, 1);
            delete appData.notes[selectedNodeId];
            
            // Também remove os nós filhos (para evitar nós "órfãos")
            nodes = nodes.filter(n => n.parentId !== selectedNodeId);
            for (const noteId in appData.notes) {
                if (appData.notes[noteId].includes(`id="${selectedNodeId}"`)) {
                    delete appData.notes[noteId];
                }
            }

            selectedNodeId = null;
            notesEditor.classList.add('hidden');
            
            saveState();
            redrawCanvas();
        }

        function setupCanvas() {
            // Evento para início do arrasto (mouse pressionado)
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left - originX) / scale;
                const mouseY = (e.clientY - rect.top - originY) / scale;

                draggedNode = null;
                for (const node of nodes) {
                    if (isPointInCircle(mouseX, mouseY, node.x, node.y, 50)) {
                        isNodeDragging = true;
                        draggedNode = node;
                        break;
                    }
                }

                // Se não clicou em um nó, ativa o arrasto do canvas
                if (!isNodeDragging) {
                    isCanvasDragging = true;
                    canvas.classList.add('grabbing');
                }
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            // Evento para o fim do arrasto (mouse solto)
            canvas.addEventListener('mouseup', () => {
                isCanvasDragging = false;
                isNodeDragging = false;
                draggedNode = null;
                canvas.classList.remove('grabbing');
                // Salva o estado após soltar um nó ou o canvas para o histórico
                saveState();
            });

            // Evento para o movimento do mouse
            canvas.addEventListener('mousemove', (e) => {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;

                if (isNodeDragging && draggedNode) {
                    // Se um nó está sendo arrastado, move o nó
                    draggedNode.x += dx / scale;
                    draggedNode.y += dy / scale;
                    redrawCanvas();
                } else if (isCanvasDragging) {
                    // Se o canvas está sendo arrastado, move o canvas
                    originX += dx;
                    originY += dy;
                    redrawCanvas();
                }

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            // Evento de clique para seleção de nó
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left - originX) / scale;
                const mouseY = (e.clientY - rect.top - originY) / scale;

                let clickedNode = null;
                for (const node of nodes) {
                    if (isPointInCircle(mouseX, mouseY, node.x, node.y, 50)) { // 50 é o raio do nó
                        clickedNode = node;
                        break;
                    }
                }

                if (clickedNode) {
                    selectedNodeId = clickedNode.id;
                    notesEditor.classList.remove('hidden');
                    noteTitleInput.value = clickedNode.text;
                    noteContentDiv.innerHTML = appData.notes[clickedNode.id] || '';
                } else {
                    selectedNodeId = null;
                    notesEditor.classList.add('hidden');
                }
                redrawCanvas();
            });

            // Evento de duplo clique para edição de texto do nó
            canvas.addEventListener('dblclick', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left - originX) / scale;
                const mouseY = (e.clientY - rect.top - originY) / scale;

                let clickedNode = null;
                for (const node of nodes) {
                    if (isPointInCircle(mouseX, mouseY, node.x, node.y, 50)) {
                        clickedNode = node;
                        break;
                    }
                }

                if (clickedNode) {
                    const newText = prompt('Editar texto do nó:', clickedNode.text);
                    if (newText !== null && newText.trim() !== '') {
                        clickedNode.text = newText;
                        saveState();
                        redrawCanvas();
                        if (selectedNodeId === clickedNode.id) {
                            noteTitleInput.value = newText;
                        }
                    }
                }
            });
        }

        // Adiciona um novo nó filho ao nó selecionado
        function addNode() {
            const parentId = selectedNodeId || 'root';
            const parentNode = nodes.find(n => n.id === parentId);
            if (!parentNode) return;

            const newNodeId = `node-${Date.now()}`;
            const depth = getNodeDepth(parentNode.id) + 1;
            const newNode = {
                id: newNodeId,
                parentId: parentId,
                text: 'Novo Nó',
                x: parentNode.x + 200,
                y: parentNode.y + Math.random() * 100 - 50,
                color: colorThemes[currentTheme][depth] || colorThemes[currentTheme][colorThemes.length - 1],
                note: ''
            };
            nodes.push(newNode);
            appData.notes[newNodeId] = '';
            
            saveState();
            redrawCanvas();
        }

        // Salva o conteúdo da nota associado ao nó selecionado
        function saveNoteContent() {
            if (selectedNodeId) {
                appData.notes[selectedNodeId] = noteContentDiv.innerHTML;
            }
        }
        
        // Salva o título do nó quando editado no painel de notas
        function saveNodeTitle() {
            if (selectedNodeId) {
                const node = nodes.find(n => n.id === selectedNodeId);
                if (node) {
                    node.text = noteTitleInput.value;
                    redrawCanvas();
                }
            }
        }

        // Funções de desenho
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(originX, originY);
            ctx.scale(scale, scale);

            // Desenha as linhas primeiro
            for (const node of nodes) {
                if (node.parentId) {
                    const parentNode = nodes.find(n => n.id === node.parentId);
                    if (parentNode) {
                        drawLine(parentNode.x, parentNode.y, node.x, node.y, '#9ca3af');
                    }
                }
            }

            // Desenha os nós por cima das linhas
            for (const node of nodes) {
                drawNode(node);
            }

            ctx.restore();
        }

        function drawLine(x1, y1, x2, y2, color) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawNode(node) {
            // Desenha a sombra
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            // Estiliza o nó
            ctx.beginPath();
            ctx.arc(node.x, node.y, 50, 0, 2 * Math.PI);
            ctx.fillStyle = node.color;
            ctx.fill();

            // Desenha a borda do nó selecionado
            if (selectedNodeId === node.id) {
                ctx.shadowColor = 'transparent'; // Remove a sombra para a borda
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#3b82f6';
                ctx.stroke();
            }
            
            // Reinicia a sombra para o texto
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;

            // Desenha o texto do nó
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '16px Inter, sans-serif';
            ctx.fillText(node.text, node.x, node.y);
            
            // Limpa a sombra para o próximo desenho
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        }
        
        // Verifica se um ponto está dentro de um círculo
        function isPointInCircle(px, py, cx, cy, r) {
            const distance = Math.sqrt(Math.pow(px - cx, 2) + Math.pow(py - cy, 2));
            return distance <= r;
        }

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }

        // Função para formatar texto no editor de notas
        function formatDoc(command, value) {
            document.execCommand(command, false, value);
            noteContentDiv.focus();
        }
        
        // --- Lógica de redimensionamento de coluna ---
        function setupResizing() {
            const resizeHandle = document.getElementById('resizeHandle');
            let isResizing = false;
            let initialX = 0;
            let initialNotesWidth = 0;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                initialX = e.clientX;
                initialNotesWidth = notesEditor.offsetWidth;
                document.body.style.cursor = 'col-resize';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const dx = initialX - e.clientX;
                let newWidth = initialNotesWidth + dx;
                
                // Limites de 30% e 100% da largura da janela
                const minWidth = window.innerWidth * 0.3;
                const maxWidth = window.innerWidth;

                if (newWidth < minWidth) {
                    newWidth = minWidth;
                }
                
                if (newWidth > maxWidth) {
                    newWidth = maxWidth;
                }

                // Ajusta a largura da coluna direita (notas)
                notesEditor.style.width = `${newWidth}px`;
                notesEditor.style.flexShrink = 0; // Impede que o flexbox encolha
                notesEditor.style.flexGrow = 0; // Impede que o flexbox cresça
                
                // Ajusta a largura da coluna esquerda (mapa mental)
                mindMapContainer.style.width = `${window.innerWidth - newWidth - resizeHandle.offsetWidth}px`;
                mindMapContainer.style.flexShrink = 0;
                mindMapContainer.style.flexGrow = 0;

                // Redesenha o canvas para ajustar à nova largura
                resizeCanvas();
                redrawCanvas();
            });

            document.addEventListener('mouseup', () => {
                isResizing = false;
                document.body.style.cursor = 'default';
            });
        }


        window.onload = init;
    </script>
</body>
</html>
