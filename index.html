<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aplicativo de Produtividade e Colaboração</title>
    <!-- Inclui a fonte Inter -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">
    <!-- Inclui Tailwind CSS para estilização rápida -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inclui Font Awesome para ícones -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        
        .flex-container {
            display: flex;
            height: 100vh;
        }

        /* Estiliza o canvas do mapa mental */
        #mindMapCanvas {
            background-color: #f8f9fa;
            cursor: grab;
        }
        #mindMapCanvas.grabbing {
            cursor: grabbing;
        }

        /* Estiliza o botão de redimensionamento */
        #resizeHandle {
            width: 10px;
            cursor: col-resize;
            background-color: #e2e8f0;
            border-left: 1px solid #cbd5e1;
            border-right: 1px solid #cbd5e1;
            transition: background-color 0.2s;
        }
        #resizeHandle:hover {
            background-color: #cbd5e1;
        }

        /* Estiliza os botões da barra de ferramentas */
        .toolbar-btn {
            @apply py-2 px-3 bg-white border border-gray-300 rounded-xl shadow transition-colors duration-200 hover:bg-gray-200;
        }
        .toolbar-btn i {
            @apply text-gray-600;
        }
        /* Estiliza o editor de notas */
        #notesEditor {
            @apply bg-white transition-all duration-300 ease-in-out;
        }
        #notesEditor.hidden {
            display: none;
        }
        /* Estiliza a área de conteúdo do editor WYSIWYG */
        #noteContent {
            @apply w-full p-4 border rounded-lg resize-none min-h-[300px] outline-none focus:ring-2 focus:ring-blue-500;
        }
        /* Estilos para os cabeçalhos no editor de notas */
        #noteContent h1 { font-size: 2em; font-weight: bold; }
        #noteContent h2 { font-size: 1.75em; font-weight: bold; }
        #noteContent h3 { font-size: 1.5em; font-weight: bold; }
        #noteContent h4 { font-size: 1.25em; font-weight: bold; }
        #noteContent h5 { font-size: 1.1em; font-weight: bold; }
        #noteContent h6 { font-size: 1em; font-weight: bold; }
        
        /* Estilos para listas no editor de notas */
        #noteContent ul {
            list-style-type: disc;
            padding-left: 1.5rem;
        }
        #noteContent ol {
            list-style-type: decimal;
            padding-left: 1.5rem;
        }

        /* Estiliza os botões do editor de notas */
        .notes-toolbar-btn {
            @apply p-2 rounded-md transition-colors duration-200 hover:bg-gray-200;
        }
        .notes-toolbar-btn i {
            @apply text-gray-600;
        }
        /* Define a classe para o nó selecionado no canvas */
        .selected-node {
            animation: pulse-border 1s infinite alternate;
        }

        /* Animação para o pulso do nó */
        @keyframes pulse-border {
            from {
                filter: drop-shadow(0 0 2px rgba(59, 130, 246, 0.5));
            }
            to {
                filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.8));
            }
        }
        
        /* Estilização da Pop-up */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
        }

        .modal-content {
            @apply bg-white p-8 rounded-lg shadow-xl max-w-sm w-full;
            background: #fff;
            padding: 20px;
            border-radius: 6px;
        }
        /* Estilização para os botões de tema e forma */
        .dropdown-btn {
            @apply w-full text-left py-2 px-4 rounded-md transition-colors duration-200 hover:bg-gray-100;
        }
        .color-circle {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            border: 1px solid rgba(0,0,0,0.1);
        }

        /* Estilização do seletor de cores individual */
        #colorPickerModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 60;
        }

        #colorPickerModal.active {
            display: flex;
        }

        .color-picker-content {
            @apply bg-white p-6 rounded-lg shadow-xl w-80;
            background: #fff;
            padding: 20px;
            border-radius: 6px;
        }

        #colorPickerArea {
            position: relative;
            width: 100%;
            padding-top: 100%; /* Proporção 1:1 */
            background: hsl(0, 100%, 50%);
        }

        #colorPickerSelector {
            position: absolute;
            width: 10px;
            height: 10px;
            border: 1px solid white;
            border-radius: 50%;
            box-shadow: 0 0 0 1px black, inset 0 0 0 1px black;
            cursor: pointer;
            transform: translate(-50%, -50%);
        }

        .color-picker-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #whiteOverlay {
            background: linear-gradient(to right, white, rgba(255, 255, 255, 0));
        }

        #blackOverlay {
            background: linear-gradient(to top, black, rgba(0, 0, 0, 0));
        }

        #hueSlider {
            width: 100%;
            height: 10px;
            background: linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00);
            border-radius: 5px;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        #hueSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: white;
            border: 1px solid black;
        }

        #selectedColorPreview {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #ccc;
        }

        /* Estilo para o campo de edição de nó */
        #nodeEditorInput {
            position: absolute;
            display: none;
            background-color: transparent;
            color: white;
            text-align: center;
            border: 1px dashed #fff;
            font-family: 'Inter', sans-serif;
            resize: none;
            overflow: hidden;
            padding: 10px;
            box-sizing: border-box;
            z-index: 10;
        }
        
        #projectNameInput {
            background-color: #fff;
            border: 1px solid transparent;
            border-radius: 5px;
            padding: 2px 6px;
            transition: border-color: 0.2s;
        }
        #projectNameInput:hover, #projectNameInput:focus {
            border-color: #cbd5e1;
        }

        #contextMenu {
            position: absolute;
            display: none;
            z-index: 100;
        }
        
        /* Estilos para o seletor de Emojis */
        .emoji-category h5 {
            @apply text-sm font-bold text-gray-500 my-2 px-1;
        }
        .emoji-btn {
            @apply text-2xl p-1 rounded-md transition-colors duration-150 hover:bg-gray-200 cursor-pointer;
        }
        .current-emoji-item {
            @apply relative;
        }
        .current-emoji-item .remove-emoji-btn {
            @apply absolute -top-1 -right-1 bg-red-500 text-white rounded-full w-4 h-4 flex items-center justify-center text-xs opacity-0 transition-opacity duration-200 cursor-pointer;
        }
        .current-emoji-item:hover .remove-emoji-btn {
            @apply opacity-100;
        }
        
        .color-swatch {
            @apply w-6 h-6 rounded-full cursor-pointer border-2 border-transparent hover:border-gray-400;
        }

    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="flex-container">
        <!-- Editor de Mapas Mentais (Coluna Esquerda) -->
        <div id="mindMapContainer" class="relative flex flex-col h-full bg-white shadow-lg" style="width: 60%;">
            <!-- Barra de Funções Principal 01 -->
            <div id="main-menu-bar" class="p-1 flex items-center border-b bg-gray-100">
                <div class="relative">
                    <button id="fileMenuBtn" class="px-3 py-1 rounded-md hover:bg-gray-200 text-sm">Arquivo</button>
                    <div id="fileMenuDropdown" class="absolute top-full left-0 mt-1 p-2 bg-white rounded-lg shadow-xl border hidden w-56 z-20">
                        <div class="flex flex-col space-y-1">
                            <button id="newProjectBtn" class="dropdown-btn"><i class="fa-solid fa-file-circle-plus w-5 mr-2"></i> Novo Projeto</button>
                            <button id="saveProjectBtn" class="dropdown-btn"><i class="fa-solid fa-download w-5 mr-2"></i> Salvar Projeto</button>
                            <input type="file" id="loadFileInput" accept=".json" class="hidden">
                            <button id="loadProjectBtn" class="dropdown-btn"><i class="fa-solid fa-upload w-5 mr-2"></i> Carregar Projeto</button>
                        </div>
                    </div>
                </div>
                <div class="relative">
                    <button id="helpMenuBtn" class="px-3 py-1 rounded-md hover:bg-gray-200 text-sm">Ajuda</button>
                    <div id="helpMenuDropdown" class="absolute top-full left-0 mt-1 p-2 bg-white rounded-lg shadow-xl border hidden w-56 z-20">
                        <div class="flex flex-col space-y-1">
                            <button id="featuresBtn" class="dropdown-btn"><i class="fa-solid fa-list-check w-5 mr-2"></i> Funcionalidades</button>
                            <div class="border-t my-1"></div>
                            <button id="aboutBtn" class="dropdown-btn"><i class="fa-solid fa-circle-info w-5 mr-2"></i> Sobre o Aplicativo</button>
                        </div>
                    </div>
                </div>
                <input type="text" id="projectNameInput" class="text-sm font-semibold text-gray-700 ml-2" value="Meu Projeto">
                <!-- Ícones de Redes Sociais -->
                <div class="ml-auto flex items-center space-x-2 pr-2">
                    <a href="https://www.linkedin.com/in/alexandrepolselli/" target="_blank" class="text-gray-500 hover:text-blue-700" title="LinkedIn"><i class="fa-brands fa-linkedin fa-lg"></i></a>
                    <a href="http://datauniverse.com.br/" target="_blank" class="text-gray-500 hover:text-orange-500" title="Blog"><i class="fa-solid fa-blog fa-lg"></i></a>
                    <a href="https://conversionzone.com.br/" target="_blank" class="text-gray-500 hover:text-green-600" title="Consultoria"><i class="fa-solid fa-briefcase fa-lg"></i></a>
                    <a href="https://github.com/cerqueiralex" target="_blank" class="text-gray-500 hover:text-gray-800" title="Github"><i class="fa-brands fa-github fa-lg"></i></a>
                    <a href="https://www.youtube.com/@datauniverseblog/videos" target="_blank" class="text-gray-500 hover:text-red-600" title="Youtube"><i class="fa-brands fa-youtube fa-lg"></i></a>
                </div>
            </div>

            <!-- Barra de Ferramentas Superior -->
            <div class="p-4 flex items-center justify-between border-b bg-gray-50">
                <div class="flex space-x-3">
                    <button id="undoMindMapBtn" class="toolbar-btn" title="Desfazer (Ctrl + Z)"><i class="fa-solid fa-rotate-left"></i></button>
                    <button id="redoMindMapBtn" class="toolbar-btn" title="Refazer (Ctrl + Y)"><i class="fa-solid fa-rotate-right"></i></button>
                    <button id="addNodeBtn" class="toolbar-btn" title="Adicionar Novo Nó (TAB)"><i class="fa-solid fa-plus"></i></button>
                    <button id="addFloatingNodeBtn" class="toolbar-btn" title="Adicionar Tópico Flutuante"><i class="fa-solid fa-brain"></i></button>
                    <button id="removeNodeBtn" class="toolbar-btn" title="Remover Nó (Delete)"><i class="fa-solid fa-trash-can"></i></button>
                    
                    <!-- Botão e Painel de Emojis -->
                    <div class="relative">
                        <button id="emojiBtn" class="toolbar-btn" title="Adicionar Emoji"><i class="fa-solid fa-face-smile"></i></button>
                        <div id="emojiPickerPanel" class="absolute top-12 left-0 p-3 bg-white rounded-lg shadow-xl border hidden w-80 z-30">
                            <div class="flex justify-between items-center mb-2">
                                <h4 class="font-semibold text-gray-700">Adicionar Emojis</h4>
                                <button id="closeEmojiPanelBtn" class="text-gray-500 hover:text-gray-800"><i class="fa-solid fa-xmark"></i></button>
                            </div>
                            <div class="mb-2 p-2 bg-gray-100 rounded-md min-h-[40px]">
                                <h5 class="text-xs font-bold text-gray-500 mb-1">NO NÓ</h5>
                                <div id="currentEmojisContainer" class="flex flex-wrap gap-1 text-2xl">
                                    <!-- Emojis atuais do nó serão inseridos aqui -->
                                </div>
                            </div>
                            <input type="text" id="emojiSearchInput" placeholder="Buscar emoji..." class="w-full border rounded-md p-2 mb-2 text-sm">
                            <div id="emojiListContainer" class="max-h-48 overflow-y-auto">
                                <!-- Categorias e emojis serão inseridos aqui -->
                            </div>
                            <button id="removeAllEmojisBtn" class="w-full text-center mt-2 py-1 px-2 text-sm text-red-600 rounded-md hover:bg-red-100">Remover Todos</button>
                        </div>
                    </div>
                    
                    <!-- Dropdown com temas de cores -->
                    <div class="relative">
                        <button id="colorPaletteBtn" class="toolbar-btn" title="Paleta de Cores"><i class="fa-solid fa-palette"></i></button>
                        <div id="colorPicker" class="absolute top-12 left-0 p-2 bg-white rounded-lg shadow-xl border hidden w-40 z-20">
                            <div class="flex flex-col space-y-1">
                                <button class="dropdown-btn" data-theme="vermelho"><span class="color-circle mr-2 inline-block" style="background-color: #bb0e0e;"></span> Vermelho</button>
                                <button class="dropdown-btn" data-theme="azul"><span class="color-circle mr-2 inline-block" style="background-color: #1e3a8a;"></span> Azul</button>
                                <button class="dropdown-btn" data-theme="verde"><span class="color-circle mr-2 inline-block" style="background-color: #166534;"></span> Verde</button>
                                <button class="dropdown-btn" data-theme="roxo"><span class="color-circle mr-2 inline-block" style="background-color: #4c1d95;"></span> Roxo</button>
                                <button class="dropdown-btn" data-theme="cinza"><span class="color-circle mr-2 inline-block" style="background-color: #3f3f46;"></span> Cinza</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Dropdown para alterar a forma de todos os nós -->
                    <div class="relative">
                        <button id="globalShapeBtn" class="toolbar-btn" title="Alterar Formato dos Nós"><i class="fa-solid fa-shapes"></i></button>
                        <div id="globalShapePicker" class="absolute top-12 left-0 p-2 bg-white rounded-lg shadow-xl border hidden w-40 z-20">
                            <div class="flex flex-col space-y-1">
                                <button class="dropdown-btn" data-shape="circle"><i class="fa-regular fa-circle w-5 mr-2"></i> Círculo</button>
                                <button class="dropdown-btn" data-shape="square"><i class="fa-regular fa-square w-5 mr-2"></i> Quadrado</button>
                                <button class="dropdown-btn" data-shape="rectangle"><i class="fa-solid fa-square-full w-5 mr-2"></i> Retângulo</button>
                            </div>
                        </div>
                    </div>

                    <!-- Dropdown para alterar o tipo de linha de conexão -->
                    <div class="relative">
                        <button id="lineTypeBtn" class="toolbar-btn" title="Tipo de Conexão"><i class="fa-solid fa-share-nodes"></i></button>
                        <div id="lineTypePicker" class="absolute top-12 left-0 p-2 bg-white rounded-lg shadow-xl border hidden w-52 z-20">
                            <div class="flex flex-col space-y-1">
                                <button class="dropdown-btn" data-line-type="line"><i class="fa-solid fa-minus w-5 mr-2"></i> Linha</button>
                                <button class="dropdown-btn" data-line-type="angled"><i class="fa-solid fa-turn-down w-5 -scale-y-100 mr-2"></i> Conector Angulado</button>
                                <button class="dropdown-btn" data-line-type="curved"><i class="fa-solid fa-wave-square w-5 mr-2"></i> Conector Curvado</button>
                            </div>
                        </div>
                    </div>
                    <!-- Dropdown para alterar a arquitetura do mapa -->
                    <div class="relative">
                        <button id="layoutBtn" class="toolbar-btn" title="Arquitetura do Mapa"><i class="fa-solid fa-sitemap"></i></button>
                        <div id="layoutPicker" class="absolute top-12 left-0 p-2 bg-white rounded-lg shadow-xl border hidden w-48 z-20">
                            <div class="flex flex-col space-y-1">
                                <button class="dropdown-btn" data-layout="right"><i class="fa-solid fa-arrow-right w-5 mr-2"></i> Direita</button>
                                <button class="dropdown-btn" data-layout="left"><i class="fa-solid fa-arrow-left w-5 mr-2"></i> Esquerda</button>
                                <button class="dropdown-btn" data-layout="top-down"><i class="fa-solid fa-arrow-down w-5 mr-2"></i> Top down</button>
                                <button class="dropdown-btn" data-layout="bottom-up"><i class="fa-solid fa-arrow-up w-5 mr-2"></i> Bottom Up</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Canvas do Mapa Mental -->
            <canvas id="mindMapCanvas" class="flex-grow"></canvas>
            <!-- Campo de texto para edição de nós -->
            <textarea id="nodeEditorInput"></textarea>

            <!-- Painel de Estatísticas -->
            <div id="statsPanel" class="absolute bottom-4 left-4 bg-black bg-opacity-50 text-white text-xs rounded-lg px-3 py-1 flex space-x-4">
                <div>Zoom: <span id="zoomLevel">100%</span></div>
                <div>Nós: <span id="nodeCount">1</span></div>
            </div>

            <!-- Controles de Navegação do Canvas (Canto Inferior Direito) -->
            <div class="absolute bottom-4 right-4 flex flex-col space-y-2">
                <button id="zoomInBtn" class="toolbar-btn shadow-md"><i class="fa-solid fa-plus"></i></button>
                <button id="zoomOutBtn" class="toolbar-btn shadow-md"><i class="fa-solid fa-minus"></i></button>
                <button id="recenterBtn" class="toolbar-btn shadow-md"><i class="fa-solid fa-expand"></i></button>
            </div>
        </div>

        <!-- Botão de redimensionamento (o novo elemento) -->
        <div id="resizeHandle"></div>

        <!-- Editor de Notas (Coluna Direita) -->
        <div id="notesEditor" class="hidden flex flex-col h-full bg-white shadow-xl" style="width: 40%;">
            <!-- Barra de Ferramentas do Editor de Notas -->
            <div class="flex items-center justify-between p-4 border-b bg-gray-50">
                <input id="noteTitle" type="text" placeholder="Título da Nota" class="flex-grow text-lg font-semibold bg-transparent border-none outline-none focus:ring-0">
                <div class="flex space-x-2">
                    <button id="closeNotesBtn" class="notes-toolbar-btn" title="Fechar"><i class="fa-solid fa-xmark"></i></button>
                </div>
            </div>
            <div class="flex items-center space-x-2 p-4 border-b bg-gray-50 flex-wrap">
                <button class="notes-toolbar-btn" onclick="formatDoc('bold')" title="Negrito"><i class="fa-solid fa-bold"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('italic')" title="Itálico"><i class="fa-solid fa-italic"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('underline')" title="Sublinhado"><i class="fa-solid fa-underline"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('strikeThrough')" title="Tachado"><i class="fa-solid fa-strikethrough"></i></button>
                <button id="createLinkBtn" class="notes-toolbar-btn" title="Criar Link"><i class="fa-solid fa-link"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('justifyLeft')" title="Alinhar à Esquerda"><i class="fa-solid fa-align-left"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('justifyCenter')" title="Alinhar ao Centro"><i class="fa-solid fa-align-center"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('justifyRight')" title="Alinhar à Direita"><i class="fa-solid fa-align-right"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('insertUnorderedList')" title="Lista com Marcadores"><i class="fa-solid fa-list-ul"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('insertOrderedList')" title="Lista Numerada"><i class="fa-solid fa-list-ol"></i></button>
                <button class="notes-toolbar-btn" onclick="formatDoc('removeFormat')" title="Remover Formatação"><i class="fa-solid fa-text-slash"></i></button>
                
                <!-- Botão de Cor do Texto -->
                <button id="textColorBtn" class="notes-toolbar-btn" title="Cor do Texto"><i class="fa-solid fa-paint-brush"></i></button>

                <!-- Botão de Destacar Texto -->
                <button id="highlightColorBtn" class="notes-toolbar-btn" title="Destacar Texto"><i class="fa-solid fa-highlighter"></i></button>

                <select onchange="formatDoc('formatBlock', this.value)" class="p-1 rounded-md bg-white border">
                    <option value="p">Parágrafo</option>
                    <option value="h1">Título 1</option>
                    <option value="h2">Título 2</option>
                    <option value="h3">Título 3</option>
                    <option value="h4">Título 4</option>
                    <option value="h5">Título 5</option>
                    <option value="h6">Título 6</option>
                </select>
                <!-- Botão para abrir o seletor de cor individual -->
                <button id="individualColorBtn" class="notes-toolbar-btn" title="Alterar Cor do Nó"><i class="fa-solid fa-fill-drip"></i></button>
            </div>
            
            <!-- Conteúdo do Editor de Notas (WYSIWYG) -->
            <div id="noteContent" contenteditable="true" class="flex-grow p-6 outline-none focus:ring-0 overflow-y-auto"></div>
        </div>
    </div>

    <!-- Pop-up de Novo Projeto (oculto por padrão) -->
    <div id="newProjectModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold">Novo Projeto</h3>
                <button id="closeModalBtn" class="text-gray-500 hover:text-gray-800"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <p class="mb-6 text-gray-700">Tem certeza que deseja criar um novo projeto e apagar o arquivo atual?</p>
            <div class="flex justify-end space-x-4">
                <button id="confirmNewProjectBtn" class="bg-red-500 text-white font-bold py-2 px-4 rounded-md hover:bg-red-600 transition-colors duration-200">Sim</button>
                <button id="cancelNewProjectBtn" class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-md hover:bg-gray-300 transition-colors duration-200">Não</button>
            </div>
        </div>
    </div>

    <!-- Pop-up Sobre o Aplicativo (oculto por padrão) -->
    <div id="aboutModal" class="modal-overlay hidden">
        <div class="modal-content max-w-lg">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold">Sobre esse aplicativo</h3>
                <button id="closeAboutModalBtn" class="text-gray-500 hover:text-gray-800"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <p class="mb-4 text-gray-700 text-center">Este é um aplicativo de produtividade versátil que combina um editor de mapas mentais com um poderoso sistema de anotações. Organize suas ideias visualmente, crie conexões e aprofunde seus tópicos com notas detalhadas, tudo em um só lugar. Ideal para brainstorming, planejamento de projetos e estudos.</p>
            <p class="mb-6 text-gray-700 text-center text-sm">Desenvolvido por Alexandre Polselli Cerqueira.</p>
            <div class="flex justify-center space-x-4">
                <a href="https://www.linkedin.com/in/alexandrepolselli/" target="_blank" class="text-gray-500 hover:text-blue-700" title="LinkedIn"><i class="fa-brands fa-linkedin fa-xl"></i></a>
                <a href="http://datauniverse.com.br/" target="_blank" class="text-gray-500 hover:text-orange-500" title="Blog"><i class="fa-solid fa-blog fa-xl"></i></a>
                <a href="https://conversionzone.com.br/" target="_blank" class="text-gray-500 hover:text-green-600" title="Consultoria"><i class="fa-solid fa-briefcase fa-xl"></i></a>
                <a href="https://github.com/cerqueiralex" target="_blank" class="text-gray-500 hover:text-gray-800" title="Github"><i class="fa-brands fa-github fa-xl"></i></a>
                <a href="https://www.youtube.com/@datauniverseblog/videos" target="_blank" class="text-gray-500 hover:text-red-600" title="Youtube"><i class="fa-brands fa-youtube fa-xl"></i></a>
            </div>
        </div>
    </div>

    <!-- Pop-up de Funcionalidades (oculto por padrão) -->
    <div id="featuresModal" class="modal-overlay hidden">
        <div class="modal-content max-w-2xl flex flex-col" style="max-height: 80vh;">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-xl font-bold">Funcionalidades e Atalhos</h3>
                <button id="closeFeaturesModalBtn" class="text-gray-500 hover:text-gray-800"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div class="text-gray-700 text-sm space-y-4 overflow-y-auto pr-4">
                <h4 class="font-bold text-lg">Gerenciamento de Projeto</h4>
                <ul class="list-disc pl-5 space-y-1">
                    <li><b>Nome do Projeto:</b> Clique no nome do projeto na barra superior para editá-lo. O nome é salvo ao pressionar 'Enter' ou clicar fora.</li>
                    <li><b>Novo Projeto:</b> Cria um novo mapa mental em branco (Arquivo > Novo Projeto).</li>
                    <li><b>Salvar Projeto:</b> Salva o projeto atual como um arquivo .json com o nome definido (Arquivo > Salvar Projeto).</li>
                    <li><b>Carregar Projeto:</b> Carrega um mapa mental a partir de um arquivo .json (Arquivo > Carregar Projeto).</li>
                </ul>

                <h4 class="font-bold text-lg">Manipulação de Nós</h4>
                <ul class="list-disc pl-5 space-y-1">
                    <li><b>Adicionar Nó Filho:</b> Adiciona um nó filho ao nó selecionado. Atalho: <code>Tab</code>.</li>
                    <li><b>Adicionar Nó Irmão:</b> Adiciona um nó no mesmo nível do nó selecionado. Atalho: <code>Enter</code>.</li>
                    <li><b>Adicionar Tópico Flutuante:</b> Cria um novo nó raiz independente no centro da tela.</li>
                    <li><b>Remover Nó:</b> Remove o nó selecionado e todos os seus filhos. Atalho: <code>Delete</code> ou <code>Backspace</code>.</li>
                    <li><b>Editar Texto:</b> Dê um duplo clique em um nó para editar seu texto diretamente.</li>
                    <li><b>Recolher/Expandir Filhos:</b> Clique no círculo na borda de um nó para recolher ou expandir seus filhos.</li>
                </ul>

                <h4 class="font-bold text-lg">Navegação e Visualização</h4>
                 <ul class="list-disc pl-5 space-y-1">
                    <li><b>Mover Canvas (Pan):</b> Clique e arraste em uma área vazia do canvas.</li>
                    <li><b>Mover Nó:</b> Clique e arraste um nó para reposicioná-lo (seus filhos se moverão junto).</li>
                    <li><b>Zoom:</b> Use os botões de +/- no canto, o gesto de pinça no trackpad/tela sensível ao toque, ou segure <code>Ctrl</code> e use a roda do mouse.</li>
                    <li><b>Recentralizar:</b> Clica no botão de expandir para centralizar o mapa na tela.</li>
                </ul>

                <h4 class="font-bold text-lg">Personalização e Estilo</h4>
                <ul class="list-disc pl-5 space-y-1">
                    <li><b>Adicionar Emojis:</b> Com um nó selecionado, clique no ícone de emoji para abrir o painel. Adicione ou remova emojis que aparecerão ao lado do texto do nó.</li>
                    <li><b>Paleta de Cores:</b> Altere o tema de cores de todo o mapa mental.</li>
                    <li><b>Formato dos Nós:</b> Altere a forma de todos os nós do mapa para círculo ou quadrado.</li>
                    <li><b>Tipo de Conexão:</b> Escolha entre linhas retas, anguladas ou curvadas para conectar os nós.</li>
                    <li><b>Arquitetura do Mapa:</b> Reorganize o layout do mapa para crescer para a direita, esquerda, para baixo ou para cima.</li>
                    <li><b>Cor Individual do Nó:</b> No painel de notas, use o seletor de cores para alterar a cor apenas do nó selecionado.</li>
                </ul>

                <h4 class="font-bold text-lg">Editor de Notas</h4>
                <p>Selecione um nó para abrir o editor de notas. As seguintes formatações estão disponíveis:</p>
                <ul class="list-disc pl-5 space-y-1">
                    <li>Estilos de texto (negrito, itálico, etc.), alinhamento, listas, e títulos (H1-H6).</li>
                    <li>Criação de links, cor de texto e destaque de texto.</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Pop-up para Inserir Link (oculto por padrão) -->
    <div id="linkModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4">Inserir Link</h3>
            <input type="text" id="linkUrlInput" placeholder="https://exemplo.com" class="w-full border rounded-md p-2 mb-4">
            <div class="flex justify-end space-x-4">
                <button id="saveLinkBtn" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-md hover:bg-blue-600 transition-colors duration-200">Salvar</button>
                <button id="cancelLinkBtn" class="bg-gray-200 text-gray-800 font-bold py-2 px-4 rounded-md hover:bg-gray-300 transition-colors duration-200">Cancelar</button>
            </div>
        </div>
    </div>

    <!-- Pop-up do seletor de cor individual -->
    <div id="colorPickerModal">
        <div class="color-picker-content">
            <div class="flex justify-between items-center mb-4">
                <h4 id="colorPickerTitle" class="text-lg font-semibold">Escolher Cor</h4>
                <button id="closeColorPicker" class="text-gray-500 hover:text-gray-800"><i class="fa-solid fa-xmark"></i></button>
            </div>
            <div id="predefinedColors" class="flex flex-wrap gap-2 mb-4 justify-center">
                <!-- Cores predefinidas serão inseridas aqui -->
            </div>
            <div id="colorPickerArea" class="relative mb-4 cursor-crosshair">
                <div id="whiteOverlay" class="color-picker-overlay"></div>
                <div id="blackOverlay" class="color-picker-overlay"></div>
                <div id="colorPickerSelector"></div>
            </div>
            <input type="range" id="hueSlider" class="w-full mb-4" min="0" max="360" value="0">
            <div class="flex items-center space-x-2">
                <span id="selectedColorPreview" class="block w-6 h-6 rounded-full border border-gray-300"></span>
                <input type="text" id="hexInput" class="w-full border rounded-md p-2 text-sm font-mono" placeholder="#000000">
            </div>
        </div>
    </div>

    <script>
        // Variáveis globais para o canvas e o contexto
        const canvas = document.getElementById('mindMapCanvas');
        const ctx = canvas.getContext('2d');
        const mindMapContainer = document.getElementById('mindMapContainer');
        const notesEditor = document.getElementById('notesEditor');
        const noteTitleInput = document.getElementById('noteTitle');
        const noteContentDiv = document.getElementById('noteContent');
        const colorPaletteBtn = document.getElementById('colorPaletteBtn');
        const colorPicker = document.getElementById('colorPicker');
        const globalShapeBtn = document.getElementById('globalShapeBtn');
        const globalShapePicker = document.getElementById('globalShapePicker');
        const lineTypeBtn = document.getElementById('lineTypeBtn');
        const lineTypePicker = document.getElementById('lineTypePicker');
        const nodeEditorInput = document.getElementById('nodeEditorInput');
        const fileMenuBtn = document.getElementById('fileMenuBtn');
        const fileMenuDropdown = document.getElementById('fileMenuDropdown');
        const projectNameInput = document.getElementById('projectNameInput');
        const helpMenuBtn = document.getElementById('helpMenuBtn');
        const helpMenuDropdown = document.getElementById('helpMenuDropdown');
        const layoutBtn = document.getElementById('layoutBtn');
        const layoutPicker = document.getElementById('layoutPicker');

        // Variáveis para o seletor de emojis
        const emojiBtn = document.getElementById('emojiBtn');
        const emojiPickerPanel = document.getElementById('emojiPickerPanel');
        const closeEmojiPanelBtn = document.getElementById('closeEmojiPanelBtn');
        const emojiListContainer = document.getElementById('emojiListContainer');
        const currentEmojisContainer = document.getElementById('currentEmojisContainer');
        const emojiSearchInput = document.getElementById('emojiSearchInput');
        const removeAllEmojisBtn = document.getElementById('removeAllEmojisBtn');
        const EMOJI_FONT_SIZE = 16;
        let areEmojisLoaded = false;

        // Estado do aplicativo
        let nodes = [];
        let selectedNodeId = null;
        let scale = 1.0;
        let originX = 0;
        let originY = 0;
        let isCanvasDragging = false; 
        let isNodeDragging = false;
        let draggedNode = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let savedSelection = null; // Para salvar a seleção de texto
        let editingNode = null; // Nó atualmente em edição
        let initialPinchDistance = 0; // Para o zoom com os dedos
        let globalLayoutDirection = 'right'; // Direção padrão do layout

        // Histórico para Desfazer/Refazer
        const history = [];
        let historyIndex = -1;

        // Temas de cores para os nós
        const colorThemes = {
            'vermelho': ['#bb0e0e', '#8d0000', '#733232', '#582424', '#451b1b'],
            'azul': ['#1e3a8a', '#172554', '#3b82f6', '#3468a3', '#5f83af'],
            'verde': ['#166534', '#064e3b', '#047857', '#34d399', '#6ee7b7'],
            'roxo': ['#4c1d95', '#3b0764', '#5b21b6', '#a78bfa', '#c4b5fd'],
            'cinza': ['#3f3f46', '#27272a', '#52525b', '#a1a1aa', '#d4d4d8']
        };
        let currentTheme = 'azul';
        let globalNodeShape = 'square'; // Forma padrão para todos os nós
        let globalLineType = 'line'; // Tipo de linha padrão
        
        // Função para quebrar o texto em linhas
        function getWrappedTextLines(text, maxWidth) {
            const words = text.split(' ');
            if (words.length === 0) return [''];
            let lines = [];
            let currentLine = words[0] || '';

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const testLine = currentLine + " " + word;
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth < maxWidth && word.length > 0) {
                    currentLine = testLine;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        // Função para calcular as dimensões do nó com base no texto e emojis
        function calculateNodeDimensions(node) {
            const padding = 20;
            const maxWidth = 350;
            const lineHeight = 20;
            ctx.font = '16px Inter, sans-serif';

            const emojisText = (node.emojis || []).join('');
            const emojisWidth = ctx.measureText(emojisText).width + (emojisText ? 5 : 0); 

            const lines = getWrappedTextLines(node.text, maxWidth - (padding * 2));
            const longestLine = lines.reduce((a, b) => (ctx.measureText(a).width > ctx.measureText(b).width ? a : b), '');
            
            let textWidth = ctx.measureText(longestLine).width;
            if (lines.length === 1) { 
                textWidth += emojisWidth;
            }

            const textHeight = lines.length * lineHeight;

            return {
                width: textWidth + (padding * 2),
                height: Math.max(textHeight, EMOJI_FONT_SIZE) + (padding * 2)
            };
        }

        // Objeto de dados simulado
        let appData = {
            nodes: [],
            notes: {},
            selectedNodeId: null,
            scale: 1.0,
            originX: 0,
            originY: 0,
            globalNodeShape: 'square',
            globalLineType: 'line',
            projectName: 'Meu Projeto',
            globalLayoutDirection: 'right'
        };

        // Função para salvar o estado atual
        function saveState() {
            if (historyIndex < history.length - 1) {
                history.splice(historyIndex + 1);
            }
            history.push(JSON.stringify({ nodes: nodes, notes: appData.notes, globalNodeShape: globalNodeShape, globalLineType: globalLineType, projectName: appData.projectName, globalLayoutDirection: globalLayoutDirection }));
            historyIndex++;
        }

        // Função para carregar um estado do histórico
        function loadState(index) {
            if (index >= 0 && index < history.length) {
                const state = JSON.parse(history[index]);
                nodes = state.nodes;
                appData.notes = state.notes;
                globalNodeShape = state.globalNodeShape || 'square';
                globalLineType = state.globalLineType || 'line';
                appData.projectName = state.projectName || 'Meu Projeto';
                globalLayoutDirection = state.globalLayoutDirection || 'right';
                projectNameInput.value = appData.projectName;
                redrawCanvas();
            }
        }
        
        // --- FUNÇÕES DE UNDO/REDO CENTRALIZADAS ---
        function undoAction() {
            if (historyIndex > 0) {
                historyIndex--;
                loadState(historyIndex);
            }
        }

        function redoAction() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadState(historyIndex);
            }
        }

        // Event listeners para Desfazer/Refazer no mapa mental
        document.getElementById('undoMindMapBtn').addEventListener('click', undoAction);
        document.getElementById('redoMindMapBtn').addEventListener('click', redoAction);
        
        // --- FUNÇÕES DE SALVAR E CARREGAR PROJETO ---
        
        function slugify(text) {
            return text.toString().toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^\w\-]+/g, '')
                .replace(/\-\-+/g, '-')
                .replace(/^-+/, '')
                .replace(/-+$/, '');
        }

        // Salva o projeto como um arquivo .json
        function saveProject() {
            const projectData = {
                nodes: nodes,
                notes: appData.notes,
                globalNodeShape: globalNodeShape,
                globalLineType: globalLineType,
                projectName: appData.projectName,
                globalLayoutDirection: globalLayoutDirection
            };
            const dataStr = JSON.stringify(projectData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${slugify(appData.projectName || 'projeto')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Carrega um projeto de um arquivo .json
        function loadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    if (loadedData.nodes && loadedData.notes) {
                        nodes = loadedData.nodes;
                        globalNodeShape = loadedData.globalNodeShape || 'square';
                        globalLineType = loadedData.globalLineType || 'line';
                        appData.projectName = loadedData.projectName || 'Meu Projeto';
                        globalLayoutDirection = loadedData.globalLayoutDirection || 'right';
                        projectNameInput.value = appData.projectName;
                        
                        nodes.forEach(node => {
                            node.shape = globalNodeShape;
                            node.emojis = node.emojis || [];
                            const dims = calculateNodeDimensions(node);
                            node.width = dims.width;
                            node.height = dims.height;
                        });

                        appData.notes = loadedData.notes;
                        selectedNodeId = null;
                        notesEditor.classList.add('hidden');
                        
                        history.length = 0;
                        historyIndex = -1;
                        saveState();

                        const rootNode = nodes.find(n => n.id === 'root');
                        if (rootNode) {
                            originX = (canvas.width / 2) - rootNode.x;
                            originY = (canvas.height / 2) - rootNode.y;
                        } else {
                            originX = 0;
                            originY = 0;
                        }
                        scale = 1.0;
                        
                        applyTreeLayout();
                    } else {
                        console.error('Formato do arquivo JSON inválido.');
                    }
                } catch (error) {
                    console.error('Erro ao analisar o arquivo JSON:', error);
                }
            };
            reader.readAsText(file);
        }

        // --- LÓGICA DO NOVO PROJETO (POP-UP) ---

        const newProjectModal = document.getElementById('newProjectModal');
        const newProjectBtn = document.getElementById('newProjectBtn');
        const closeModalBtn = document.getElementById('closeModalBtn');
        const confirmNewProjectBtn = document.getElementById('confirmNewProjectBtn');
        const cancelNewProjectBtn = document.getElementById('cancelNewProjectBtn');

        newProjectBtn.addEventListener('click', () => newProjectModal.classList.remove('hidden'));
        function hideModal() { newProjectModal.classList.add('hidden'); }
        closeModalBtn.addEventListener('click', hideModal);
        cancelNewProjectBtn.addEventListener('click', hideModal);
        
        function resetProject() {
            const initialText = 'Ideia Central';
            globalNodeShape = 'square'; // Padrão alterado para quadrado
            const initialNode = { 
                id: 'root', 
                parentId: null, 
                text: initialText, 
                x: 0, y: 0, 
                color: colorThemes[currentTheme][0], 
                shape: globalNodeShape, 
                note: 'Esta é a nota para o nó central.',
                emojis: [],
                isCollapsed: false
            };
            const initialDimensions = calculateNodeDimensions(initialNode);
            initialNode.width = initialDimensions.width;
            initialNode.height = initialDimensions.height;
            
            globalLineType = 'line';
            globalLayoutDirection = 'right';
            appData.projectName = 'Meu Projeto';
            projectNameInput.value = appData.projectName;
            nodes = [initialNode];
            appData.notes = { 'root': '<h1>Bem-vindo!</h1><p>Esta é a nota principal.</p>' };
            
            history.length = 0;
            historyIndex = -1;
            saveState();

            selectedNodeId = null;
            notesEditor.classList.add('hidden');
            
            originX = (canvas.width / 2);
            originY = (canvas.height / 2);
            scale = 1.0;

            redrawCanvas();
            hideModal();
        }
        confirmNewProjectBtn.addEventListener('click', resetProject);

        // --- LÓGICA DO SELETOR DE COR ---
        const colorPickerModal = document.getElementById('colorPickerModal');
        const closeColorPickerBtn = document.getElementById('closeColorPicker');
        const colorPickerArea = document.getElementById('colorPickerArea');
        const colorPickerSelector = document.getElementById('colorPickerSelector');
        const hueSlider = document.getElementById('hueSlider');
        const selectedColorPreview = document.getElementById('selectedColorPreview');
        const hexInput = document.getElementById('hexInput');
        const colorPickerTitle = document.getElementById('colorPickerTitle');
        const predefinedColorsContainer = document.getElementById('predefinedColors');

        let isPickingColor = false;
        let currentHue = 0;
        let currentSaturation = 100;
        let currentLightness = 50;
        let colorCallback = null;

        function openColorPicker(title, callback) {
            colorPickerTitle.textContent = title;
            colorCallback = callback;
            colorPickerModal.classList.add('active');
        }

        function updateColorFromPicker(e) {
            const rect = colorPickerArea.getBoundingClientRect();
            let x = e.clientX - rect.left;
            let y = e.clientY - rect.top;
            x = Math.max(0, Math.min(x, rect.width));
            y = Math.max(0, Math.min(y, rect.height));

            currentSaturation = (x / rect.width) * 100;
            currentLightness = 100 - (y / rect.height) * 100;
            
            updateColorSelectorPosition();
            updateSelectedColor();
        }

        function updateSelectedColor() {
            const hexColor = hslToHex(currentHue, currentSaturation, currentLightness);
            selectedColorPreview.style.backgroundColor = hexColor;
            hexInput.value = hexColor;
            if (colorCallback) {
                colorCallback(hexColor);
            }
        }
        
        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }
        
        function updateColorSelectorPosition() {
            const rect = colorPickerArea.getBoundingClientRect();
            const x = (currentSaturation / 100) * rect.width;
            const y = (1 - currentLightness / 100) * rect.height;
            colorPickerSelector.style.left = `${x}px`;
            colorPickerSelector.style.top = `${y}px`;
        }
        
        function initColorSwatches() {
            const colors = [
                '#FF0000', '#FFA500', '#FFFF00', '#008000', '#0000FF', '#4B0082', '#EE82EE', // Primary/Secondary
                '#FF4500', '#FFD700', '#ADFF2F', '#00FFFF', '#8A2BE2', '#C71585', // Tertiary
                '#FFFFFF', '#808080', '#000000' // White, Gray, Black
            ];
            
            predefinedColorsContainer.innerHTML = '';
            colors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.className = 'color-swatch';
                swatch.style.backgroundColor = color;
                swatch.dataset.color = color;
                swatch.addEventListener('click', () => {
                    if (colorCallback) {
                        colorCallback(color);
                        hexInput.value = color;
                        selectedColorPreview.style.backgroundColor = color;
                    }
                });
                predefinedColorsContainer.appendChild(swatch);
            });
        }

        document.getElementById('individualColorBtn').addEventListener('click', () => {
            if (selectedNodeId) {
                openColorPicker('Alterar Cor do Nó', (color) => {
                    const node = nodes.find(n => n.id === selectedNodeId);
                    if (node) {
                        node.color = color;
                        redrawCanvas();
                    }
                });
            }
        });
        
        document.getElementById('textColorBtn').addEventListener('click', () => {
            openColorPicker('Cor do Texto', (color) => {
                formatDoc('foreColor', color);
            });
        });

        document.getElementById('highlightColorBtn').addEventListener('click', () => {
            openColorPicker('Cor de Destaque', (color) => {
                formatDoc('hiliteColor', color);
            });
        });

        closeColorPickerBtn.addEventListener('click', () => {
            colorPickerModal.classList.remove('active');
            saveState();
        });

        colorPickerArea.addEventListener('mousedown', (e) => {
            isPickingColor = true;
            updateColorFromPicker(e);
        });

        document.addEventListener('mousemove', (e) => {
            if (isPickingColor) {
                updateColorFromPicker(e);
            }
        });

        document.addEventListener('mouseup', () => {
            isPickingColor = false;
        });

        hueSlider.addEventListener('input', (e) => {
            currentHue = e.target.value;
            colorPickerArea.style.backgroundColor = `hsl(${currentHue}, 100%, 50%)`;
            updateSelectedColor();
        });

        hexInput.addEventListener('change', (e) => {
            const hex = e.target.value;
            if (colorCallback) {
                colorCallback(hex);
            }
        });

        // --- LÓGICA DO SELETOR DE EMOJIS ---
        async function initEmojiPicker() {
            emojiListContainer.innerHTML = '<p class="text-gray-500 text-sm">Carregando emojis...</p>';
            try {
                const response = await fetch('https://cdn.jsdelivr.net/npm/emojibase-data/en/data.json');
                const emojiData = await response.json();
                
                const categoryMap = {
                    0: 'Smileys & Emoção', 1: 'Pessoas & Corpo', 2: 'Animais & Natureza',
                    3: 'Comida & Bebida', 4: 'Viagens & Lugares', 5: 'Atividades',
                    6: 'Objetos', 7: 'Símbolos', 8: 'Bandeiras',
                };
                const categorizedEmojis = {};

                emojiData.forEach(emoji => {
                    if (emoji.group !== undefined) {
                        const categoryName = categoryMap[emoji.group];
                        if (!categorizedEmojis[categoryName]) {
                            categorizedEmojis[categoryName] = [];
                        }
                        if (!emoji.skins) {
                           categorizedEmojis[categoryName].push(emoji.emoji);
                        }
                    }
                });
                
                emojiListContainer.innerHTML = '';
                for (const category in categorizedEmojis) {
                    const categoryDiv = document.createElement('div');
                    categoryDiv.className = 'emoji-category';
                    const title = document.createElement('h5');
                    title.textContent = category;
                    categoryDiv.appendChild(title);
                    const emojiGrid = document.createElement('div');
                    emojiGrid.className = 'flex flex-wrap gap-1';
                    categorizedEmojis[category].forEach(emoji => {
                        const span = document.createElement('span');
                        span.className = 'emoji-btn';
                        span.textContent = emoji;
                        span.onclick = () => addEmojiToNode(emoji);
                        emojiGrid.appendChild(span);
                    });
                    categoryDiv.appendChild(emojiGrid);
                    emojiListContainer.appendChild(categoryDiv);
                }
                areEmojisLoaded = true;
            } catch (error) {
                emojiListContainer.innerHTML = '<p class="text-red-500 text-sm">Falha ao carregar emojis.</p>';
                console.error("Falha ao carregar emojis:", error);
            }
            
            // Adiciona os event listeners do painel de emoji
            closeEmojiPanelBtn.addEventListener('click', () => emojiPickerPanel.classList.add('hidden'));
            removeAllEmojisBtn.addEventListener('click', () => {
                const node = nodes.find(n => n.id === selectedNodeId);
                if (node) {
                    node.emojis = [];
                    updateNodeAndRedraw(node);
                    populateEmojiPicker();
                }
            });
            emojiSearchInput.addEventListener('input', filterEmojis);
        }

        function toggleEmojiPanel() {
            if (selectedNodeId) {
                emojiPickerPanel.classList.toggle('hidden');
                if (!emojiPickerPanel.classList.contains('hidden')) {
                    populateEmojiPicker();
                }
            }
        }

        function populateEmojiPicker() {
            if (!selectedNodeId) return;
            const node = nodes.find(n => n.id === selectedNodeId);
            if (!node) return;

            currentEmojisContainer.innerHTML = '';
            (node.emojis || []).forEach((emoji, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'current-emoji-item';
                const emojiSpan = document.createElement('span');
                emojiSpan.textContent = emoji;
                const removeBtn = document.createElement('button');
                removeBtn.className = 'remove-emoji-btn';
                removeBtn.innerHTML = '<i class="fa-solid fa-xmark fa-xs"></i>';
                removeBtn.onclick = () => removeEmojiFromNode(index);
                itemDiv.appendChild(emojiSpan);
                itemDiv.appendChild(removeBtn);
                currentEmojisContainer.appendChild(itemDiv);
            });
        }

        function addEmojiToNode(emoji) {
            if (!selectedNodeId) return;
            const node = nodes.find(n => n.id === selectedNodeId);
            if (node) {
                if (!node.emojis) node.emojis = [];
                node.emojis.push(emoji);
                updateNodeAndRedraw(node);
                populateEmojiPicker();
            }
        }

        function removeEmojiFromNode(index) {
            if (!selectedNodeId) return;
            const node = nodes.find(n => n.id === selectedNodeId);
            if (node && node.emojis) {
                node.emojis.splice(index, 1);
                updateNodeAndRedraw(node);
                populateEmojiPicker();
            }
        }

        function filterEmojis() {
            const searchTerm = emojiSearchInput.value.toLowerCase();
            document.querySelectorAll('.emoji-btn').forEach(btn => {
                if (btn.textContent.includes(searchTerm)) {
                    btn.style.display = 'inline-block';
                } else {
                    btn.style.display = 'none';
                }
            });
        }
        
        function init() {
            setupCanvas();
            setupResizing();
            initEmojiPicker();
            initColorSwatches();

            window.addEventListener('resize', () => {
                resizeCanvas();
                redrawCanvas();
            });
            noteContentDiv.addEventListener('input', saveNoteContent);
            noteContentDiv.addEventListener('click', (e) => {
                if(e.target.tagName === 'A') {
                    e.preventDefault();
                    window.open(e.target.href, '_blank');
                }
            });
            noteTitleInput.addEventListener('input', saveNodeTitle);
            
            projectNameInput.addEventListener('blur', () => {
                appData.projectName = projectNameInput.value;
                saveState();
            });
            projectNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') projectNameInput.blur();
            });

            document.getElementById('closeNotesBtn').addEventListener('click', () => {
                notesEditor.classList.add('hidden');
                selectedNodeId = null;
                redrawCanvas();
            });
            document.getElementById('addNodeBtn').addEventListener('click', addNode);
            document.getElementById('removeNodeBtn').addEventListener('click', deleteNode);
            document.getElementById('addFloatingNodeBtn').addEventListener('click', addFloatingNode);
            document.getElementById('zoomInBtn').addEventListener('click', () => { scale *= 1.1; redrawCanvas(); });
            document.getElementById('zoomOutBtn').addEventListener('click', () => { scale /= 1.1; redrawCanvas(); });
            document.getElementById('recenterBtn').addEventListener('click', () => {
                originX = canvas.width / 2;
                originY = canvas.height / 2;
                scale = 1.0;
                redrawCanvas();
            });
            
            document.querySelectorAll('.dropdown-btn[data-theme]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    currentTheme = e.currentTarget.dataset.theme;
                    applyThemeToNodes();
                });
            });

            document.querySelectorAll('.dropdown-btn[data-shape]').forEach(btn => {
                btn.addEventListener('click', (e) => applyGlobalShape(e.currentTarget.dataset.shape));
            });

            document.querySelectorAll('.dropdown-btn[data-line-type]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    globalLineType = e.currentTarget.dataset.lineType;
                    saveState();
                    redrawCanvas();
                });
            });
            
            document.querySelectorAll('.dropdown-btn[data-layout]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    globalLayoutDirection = e.currentTarget.dataset.layout;
                    applyTreeLayout();
                    saveState();
                });
            });

            document.getElementById('saveProjectBtn').addEventListener('click', saveProject);
            document.getElementById('loadProjectBtn').addEventListener('click', () => document.getElementById('loadFileInput').click());
            document.getElementById('loadFileInput').addEventListener('change', loadProject);
            
            const aboutBtn = document.getElementById('aboutBtn');
            const aboutModal = document.getElementById('aboutModal');
            const closeAboutModalBtn = document.getElementById('closeAboutModalBtn');
            aboutBtn.addEventListener('click', () => aboutModal.classList.remove('hidden'));
            closeAboutModalBtn.addEventListener('click', () => aboutModal.classList.add('hidden'));
            aboutModal.addEventListener('click', (e) => { if (e.target === aboutModal) aboutModal.classList.add('hidden'); });

            const featuresBtn = document.getElementById('featuresBtn');
            const featuresModal = document.getElementById('featuresModal');
            const closeFeaturesModalBtn = document.getElementById('closeFeaturesModalBtn');
            featuresBtn.addEventListener('click', () => featuresModal.classList.remove('hidden'));
            closeFeaturesModalBtn.addEventListener('click', () => featuresModal.classList.add('hidden'));
            featuresModal.addEventListener('click', (e) => { if (e.target === featuresModal) featuresModal.classList.add('hidden'); });

            const createLinkBtn = document.getElementById('createLinkBtn');
            const linkModal = document.getElementById('linkModal');
            const saveLinkBtn = document.getElementById('saveLinkBtn');
            const cancelLinkBtn = document.getElementById('cancelLinkBtn');
            const linkUrlInput = document.getElementById('linkUrlInput');

            createLinkBtn.addEventListener('click', () => {
                const selection = window.getSelection();
                if (selection.rangeCount > 0 && !selection.getRangeAt(0).collapsed && noteContentDiv.contains(selection.anchorNode)) {
                    savedSelection = selection.getRangeAt(0).cloneRange();
                    linkModal.classList.remove('hidden');
                    linkUrlInput.value = 'https://';
                    linkUrlInput.focus();
                }
            });

            function closeLinkModal() {
                linkModal.classList.add('hidden');
                linkUrlInput.value = '';
                savedSelection = null;
            }

            cancelLinkBtn.addEventListener('click', closeLinkModal);
            linkModal.addEventListener('click', (e) => { if (e.target === linkModal) closeLinkModal(); });

            saveLinkBtn.addEventListener('click', () => {
                if (savedSelection) {
                    noteContentDiv.focus();
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(savedSelection);

                    let url = linkUrlInput.value;
                    if (url && !url.startsWith('http://') && !url.startsWith('https://')) {
                        url = 'https://' + url;
                    }

                    if (url) {
                        document.execCommand('createLink', false, url);
                        const anchor = selection.anchorNode;
                        if (anchor) {
                            const linkElement = anchor.nodeType === 3 ? anchor.parentElement : anchor;
                            if (linkElement && linkElement.tagName === 'A') {
                                linkElement.target = '_blank';
                                linkElement.style.color = 'blue';
                                linkElement.style.textDecoration = 'underline';
                            }
                        }
                    }
                    
                    closeLinkModal();
                    saveNoteContent();
                }
            });

            document.addEventListener('keydown', (e) => {
                if (document.activeElement === noteContentDiv || document.activeElement === noteTitleInput || document.activeElement === emojiSearchInput) {
                    return;
                }
                if (e.key === 'Tab' || e.key === 'Enter' || (e.ctrlKey && (e.key === 'z' || e.key === 'y'))) {
                    e.preventDefault();
                }
                if (!selectedNodeId && e.key === 'Tab') { addNode(); return; }
                if (!selectedNodeId) return;

                switch(e.key) {
                    case 'Tab': addNode(); break;
                    case 'Enter': addSiblingNode(); break;
                    case 'Delete': case 'Backspace': deleteNode(); break;
                    case 'z': if (e.ctrlKey) undoAction(); break;
                    case 'y': if (e.ctrlKey) redoAction(); break;
                }
            });

            document.addEventListener('click', (e) => {
                const target = e.target;
                const dropdowns = [
                    { btn: colorPaletteBtn, panel: colorPicker },
                    { btn: globalShapeBtn, panel: globalShapePicker },
                    { btn: lineTypeBtn, panel: lineTypePicker },
                    { btn: fileMenuBtn, panel: fileMenuDropdown },
                    { btn: helpMenuBtn, panel: helpMenuDropdown },
                    { btn: layoutBtn, panel: layoutPicker },
                    { btn: emojiBtn, panel: emojiPickerPanel }
                ];
                
                dropdowns.forEach(d => {
                    if (!d.btn.contains(target) && !d.panel.contains(target)) {
                        d.panel.classList.add('hidden');
                    }
                });
                
                if (colorPaletteBtn.contains(target)) colorPicker.classList.toggle('hidden');
                if (globalShapeBtn.contains(target)) globalShapePicker.classList.toggle('hidden');
                if (lineTypeBtn.contains(target)) lineTypePicker.classList.toggle('hidden');
                if (fileMenuBtn.contains(target)) fileMenuDropdown.classList.toggle('hidden');
                if (helpMenuBtn.contains(target)) helpMenuDropdown.classList.toggle('hidden');
                if (layoutBtn.contains(target)) layoutPicker.classList.toggle('hidden');
                if (emojiBtn.contains(target)) toggleEmojiPanel();
            });

            resizeCanvas();
            resetProject();
        }

        function getNodeDepth(nodeId) {
            let depth = 0;
            let node = nodes.find(n => n.id === nodeId);
            while (node && node.parentId !== null) {
                node = nodes.find(n => n.id === node.parentId);
                depth++;
            }
            return depth;
        }

        // Função para aplicar o tema de cores aos nós
        function applyThemeToNodes() {
            const themeColors = colorThemes[currentTheme];
            nodes.forEach(node => {
                const depth = getNodeDepth(node.id);
                // Garante que o índice não exceda o tamanho da array de cores
                const colorIndex = Math.min(depth, themeColors.length - 1);
                node.color = themeColors[colorIndex];
            });
            saveState();
            redrawCanvas();
        }

        function applyGlobalShape(shape) {
            globalNodeShape = shape;
            nodes.forEach(node => node.shape = globalNodeShape);
            saveState();
            redrawCanvas();
        }

        function applyTreeLayout() {
            const roots = nodes.filter(n => n.parentId === null);
            if (roots.length === 0) return;

            roots.forEach(root => {
                if (globalLayoutDirection === 'right' || globalLayoutDirection === 'left') {
                    function calculateSubtreeHeight(nodeId) {
                        const node = nodes.find(n => n.id === nodeId);
                        const children = nodes.filter(n => n.parentId === nodeId && !isNodeHidden(n.id));

                        if (children.length === 0 || node.isCollapsed) {
                            node.subtreeHeight = node.height;
                            return node.height;
                        }

                        const childrenTotalHeight = children.reduce((sum, child) => {
                            return sum + calculateSubtreeHeight(child.id);
                        }, 0) + (children.length - 1) * 20;

                        node.subtreeHeight = Math.max(node.height, childrenTotalHeight);
                        return node.subtreeHeight;
                    }

                    calculateSubtreeHeight(root.id);

                    function positionNodes(nodeId, x, y) {
                        const node = nodes.find(n => n.id === nodeId);
                        node.x = x;
                        node.y = y;

                        const children = nodes.filter(n => n.parentId === nodeId && !isNodeHidden(n.id));
                        if (children.length === 0 || node.isCollapsed) return;

                        const childX = (globalLayoutDirection === 'right') 
                            ? x + node.width / 2 + 50
                            : x - node.width / 2 - 50;

                        const totalChildrenHeight = children.reduce((sum, child) => sum + child.subtreeHeight, 0) + (children.length - 1) * 20;
                        
                        let currentY = y - totalChildrenHeight / 2;

                        for (const child of children) {
                            const childY = currentY + child.subtreeHeight / 2;
                            const childPosX = (globalLayoutDirection === 'right') 
                                ? childX + child.width / 2 
                                : childX - child.width / 2;
                            positionNodes(child.id, childPosX, childY);
                            currentY += child.subtreeHeight + 20;
                        }
                    }
                    positionNodes(root.id, root.x, root.y);
                } else { // Top-down or Bottom-up
                    function calculateSubtreeWidth(nodeId) {
                        const node = nodes.find(n => n.id === nodeId);
                        const children = nodes.filter(n => n.parentId === nodeId && !isNodeHidden(n.id));

                        if (children.length === 0 || node.isCollapsed) {
                            node.subtreeWidth = node.width;
                            return node.width;
                        }

                        const childrenTotalWidth = children.reduce((sum, child) => {
                            return sum + calculateSubtreeWidth(child.id);
                        }, 0) + (children.length - 1) * 50;

                        node.subtreeWidth = Math.max(node.width, childrenTotalWidth);
                        return node.subtreeWidth;
                    }

                    calculateSubtreeWidth(root.id);

                    function positionNodes(nodeId, x, y) {
                        const node = nodes.find(n => n.id === nodeId);
                        node.x = x;
                        node.y = y;

                        const children = nodes.filter(n => n.parentId === nodeId && !isNodeHidden(n.id));
                        if (children.length === 0 || node.isCollapsed) return;

                        const childY = (globalLayoutDirection === 'top-down') 
                            ? y + node.height / 2 + 20
                            : y - node.height / 2 - 20;

                        const totalChildrenWidth = children.reduce((sum, child) => sum + child.subtreeWidth, 0) + (children.length - 1) * 50;
                        
                        let currentX = x - totalChildrenWidth / 2;

                        for (const child of children) {
                            const childX = currentX + child.subtreeWidth / 2;
                            const childPosY = (globalLayoutDirection === 'top-down') 
                                ? childY + child.height / 2 
                                : childY - child.height / 2;
                            positionNodes(child.id, childX, childPosY);
                            currentX += child.subtreeWidth + 50;
                        }
                    }
                    positionNodes(root.id, root.x, root.y);
                }
            });

            redrawCanvas();
        }

        function updateNodeAndRedraw(node) {
            const newDimensions = calculateNodeDimensions(node);
            node.width = newDimensions.width;
            node.height = newDimensions.height;
            applyTreeLayout();
            saveState();
        }

        function addSiblingNode() {
            if (!selectedNodeId) return;
            const selectedNode = nodes.find(n => n.id === selectedNodeId);
            if (!selectedNode || !selectedNode.parentId) return;

            const depth = getNodeDepth(selectedNode.id);
            const themeColors = colorThemes[currentTheme];
            const colorIndex = Math.min(depth, themeColors.length - 1);

            const newNode = {
                id: `node-${Date.now()}`,
                parentId: selectedNode.parentId,
                text: 'Novo Nó',
                x: 0, y: 0,
                color: themeColors[colorIndex],
                shape: globalNodeShape,
                note: '',
                emojis: [],
                isCollapsed: false
            };
            const newDimensions = calculateNodeDimensions(newNode);
            newNode.width = newDimensions.width;
            newNode.height = newDimensions.height;

            nodes.push(newNode);
            appData.notes[newNode.id] = '';
            
            applyTreeLayout();
            saveState();
        }

        function deleteNode() {
            if (!selectedNodeId || selectedNodeId === 'root') return;
            
            let toDelete = [selectedNodeId];
            let i = 0;
            while (i < toDelete.length) {
                const currentId = toDelete[i];
                const children = nodes.filter(n => n.parentId === currentId).map(n => n.id);
                toDelete.push(...children);
                i++;
            }

            nodes = nodes.filter(n => !toDelete.includes(n.id));
            toDelete.forEach(id => delete appData.notes[id]);

            selectedNodeId = null;
            notesEditor.classList.add('hidden');
            
            applyTreeLayout();
            saveState();
        }

        function setupCanvas() {
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left - originX) / scale;
                const mouseY = (e.clientY - rect.top - originY) / scale;

                draggedNode = null;
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const node = nodes[i];
                    if (isPointInShape(mouseX, mouseY, node)) {
                        isNodeDragging = true;
                        draggedNode = node;
                        break;
                    }
                }

                if (!isNodeDragging) {
                    isCanvasDragging = true;
                    canvas.classList.add('grabbing');
                }
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            document.addEventListener('mouseup', () => {
                if(isNodeDragging || isCanvasDragging) {
                    saveState();
                }
                isCanvasDragging = false;
                isNodeDragging = false;
                draggedNode = null;
                canvas.classList.remove('grabbing');
            });

            document.addEventListener('mousemove', (e) => {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;

                if (isNodeDragging && draggedNode) {
                    const deltaX = dx / scale;
                    const deltaY = dy / scale;

                    function moveSubtree(nodeId, dX, dY) {
                        const nodeToMove = nodes.find(n => n.id === nodeId);
                        if(nodeToMove) {
                            nodeToMove.x += dX;
                            nodeToMove.y += dY;
                            const children = nodes.filter(n => n.parentId === nodeId);
                            children.forEach(child => moveSubtree(child.id, dX, dY));
                        }
                    }
                    moveSubtree(draggedNode.id, deltaX, deltaY);
                    redrawCanvas();

                } else if (isCanvasDragging) {
                    originX += dx;
                    originY += dy;
                    redrawCanvas();
                }

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });

            canvas.addEventListener('click', (e) => {
                if (isNodeDragging) return;
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left - originX) / scale;
                const mouseY = (e.clientY - rect.top - originY) / scale;

                let clickedNode = null;
                let clickedCollapseButton = false;

                for (let i = nodes.length - 1; i >= 0; i--) {
                    const node = nodes[i];
                    const children = nodes.filter(n => n.parentId === node.id);
                    if (children.length > 0) {
                        const buttonPos = getCollapseButtonPosition(node);
                        const dist = Math.sqrt(Math.pow(mouseX - buttonPos.x, 2) + Math.pow(mouseY - buttonPos.y, 2));
                        if (dist <= 8) {
                            toggleCollapse(node.id);
                            clickedCollapseButton = true;
                            break;
                        }
                    }
                    if (isPointInShape(mouseX, mouseY, node)) { 
                        clickedNode = node;
                        break;
                    }
                }

                if (clickedCollapseButton) return;

                if (clickedNode) {
                    selectedNodeId = clickedNode.id;
                    notesEditor.classList.remove('hidden');
                    noteTitleInput.value = clickedNode.text;
                    noteContentDiv.innerHTML = appData.notes[clickedNode.id] || '';
                } else {
                    selectedNodeId = null;
                    notesEditor.classList.add('hidden');
                }
                redrawCanvas();
            });

            canvas.addEventListener('dblclick', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left - originX) / scale;
                const mouseY = (e.clientY - rect.top - originY) / scale;

                let clickedNode = null;
                for (let i = nodes.length - 1; i >= 0; i--) {
                    const node = nodes[i];
                    if (isPointInShape(mouseX, mouseY, node)) {
                        clickedNode = node;
                        break;
                    }
                }

                if (clickedNode) {
                    editNode(clickedNode);
                }
            });

            canvas.addEventListener('wheel', (e) => {
                if (e.ctrlKey) {
                    e.preventDefault();
                    const zoomIntensity = 0.1;
                    const wheel = e.deltaY < 0 ? 1 : -1;
                    const zoom = Math.exp(wheel * zoomIntensity);
                    scale *= zoom;
                    redrawCanvas();
                }
            }, { passive: false });

            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    initialPinchDistance = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const currentPinchDistance = Math.hypot(
                        e.touches[0].pageX - e.touches[1].pageX,
                        e.touches[0].pageY - e.touches[1].pageY
                    );
                    const newScale = scale * (currentPinchDistance / initialPinchDistance);
                    scale = Math.max(0.1, Math.min(newScale, 5));
                    initialPinchDistance = currentPinchDistance;
                    redrawCanvas();
                }
            }, { passive: false });

            canvas.addEventListener('touchend', () => {
                initialPinchDistance = 0;
            });
        }
        
        function isPointInShape(px, py, node) {
            const { x, y, width, height } = node;
            return px >= x - width / 2 && px <= x + width / 2 && py >= y - height / 2 && py <= y + height / 2;
        }
        
        function addNode() {
            const parentId = selectedNodeId || 'root';
            const parentNode = nodes.find(n => n.id === parentId);
            if (!parentNode) return;

            const depth = getNodeDepth(parentId) + 1;
            const themeColors = colorThemes[currentTheme];
            const colorIndex = Math.min(depth, themeColors.length - 1);

            const newNode = {
                id: `node-${Date.now()}`,
                parentId: parentId,
                text: 'Novo Nó',
                x: 0, y: 0,
                color: themeColors[colorIndex],
                shape: globalNodeShape,
                note: '',
                emojis: [],
                isCollapsed: false
            };
            const newDimensions = calculateNodeDimensions(newNode);
            newNode.width = newDimensions.width;
            newNode.height = newDimensions.height;

            nodes.push(newNode);
            appData.notes[newNode.id] = '';
            
            applyTreeLayout();
            saveState();
            editNode(newNode);
        }

        function addFloatingNode() {
            const newNode = {
                id: `node-${Date.now()}`,
                parentId: null,
                text: 'Ideia Central',
                x: (canvas.width / 2 - originX) / scale,
                y: (canvas.height / 2 - originY) / scale,
                color: colorThemes[currentTheme][0],
                shape: globalNodeShape,
                note: '',
                emojis: [],
                isCollapsed: false
            };
            const newDimensions = calculateNodeDimensions(newNode);
            newNode.width = newDimensions.width;
            newNode.height = newDimensions.height;

            nodes.push(newNode);
            appData.notes[newNode.id] = '';
            
            redrawCanvas();
            saveState();
            editNode(newNode);
        }

        function saveNoteContent() {
            if (selectedNodeId) {
                appData.notes[selectedNodeId] = noteContentDiv.innerHTML;
                saveState();
            }
        }
        
        function saveNodeTitle() {
            if (selectedNodeId) {
                const node = nodes.find(n => n.id === selectedNodeId);
                if (node) {
                    node.text = noteTitleInput.value;
                    updateNodeAndRedraw(node);
                }
            }
        }

        function updateStats() {
            document.getElementById('zoomLevel').textContent = `${Math.round(scale * 100)}%`;
            document.getElementById('nodeCount').textContent = nodes.length;
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(originX, originY);
            ctx.scale(scale, scale);

            nodes.forEach(node => {
                if (node.parentId && !isNodeHidden(node.id)) {
                    const parentNode = nodes.find(n => n.id === node.parentId);
                    if (parentNode) drawLine(parentNode, node, '#9ca3af');
                }
            });

            nodes.forEach(node => {
                if (!isNodeHidden(node.id) && editingNode?.id !== node.id) {
                    drawNode(node);
                }
            });

            ctx.restore();
            updateStats();
        }

        function drawLine(fromNode, toNode, color) {
            const x1 = fromNode.x;
            const y1 = fromNode.y;
            const x2 = toNode.x;
            const y2 = toNode.y;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            
            switch (globalLineType) {
                case 'angled':
                    const midX = x1 + 40;
                    ctx.lineTo(midX, y1);
                    ctx.lineTo(midX, y2);
                    ctx.lineTo(x2, y2);
                    break;
                case 'curved':
                    const cp1x = x1 + (x2 - x1) / 2;
                    const cp1y = y1;
                    const cp2x = x1 + (x2 - x1) / 2;
                    const cp2y = y2;
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x2, y2);
                    break;
                case 'line':
                default:
                    ctx.lineTo(x2, y2);
                    break;
            }

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        function drawNode(node) {
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            ctx.beginPath();
            const { x, y, width, height } = node;
            const nodeX = x - width / 2;
            const nodeY = y - height / 2;
            
            let rx = 0;
            if (node.shape === 'square') {
                rx = 15;
            } else if (node.shape === 'circle') {
                rx = Math.min(width, height) / 2;
            } else if (node.shape === 'rectangle') {
                rx = 0;
            }

            ctx.moveTo(nodeX + rx, nodeY);
            ctx.lineTo(nodeX + width - rx, nodeY);
            if (rx > 0) ctx.quadraticCurveTo(nodeX + width, nodeY, nodeX + width, nodeY + rx);
            ctx.lineTo(nodeX + width, nodeY + height - rx);
            if (rx > 0) ctx.quadraticCurveTo(nodeX + width, nodeY + height, nodeX + width - rx, nodeY + height);
            ctx.lineTo(nodeX + rx, nodeY + height);
            if (rx > 0) ctx.quadraticCurveTo(nodeX, nodeY + height, nodeX, nodeY + height - rx);
            ctx.lineTo(nodeX, nodeY + rx);
            if (rx > 0) ctx.quadraticCurveTo(nodeX, nodeY, nodeX + rx, nodeY);
            ctx.closePath();
            ctx.fillStyle = node.color;
            ctx.fill();

            if (selectedNodeId === node.id) {
                ctx.shadowColor = 'transparent';
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#3b82f6';
                ctx.stroke();
            }
            
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            const emojisText = (node.emojis || []).join('');
            ctx.font = '16px Inter, sans-serif';
            const emojisWidth = ctx.measureText(emojisText).width;
            
            const lines = getWrappedTextLines(node.text, width - 20 - (emojisWidth > 0 ? emojisWidth + 5 : 0));
            const startY = y - ((lines.length - 1) * 20) / 2;

            lines.forEach((line, index) => {
                const isLastLine = index === lines.length - 1;
                const textWidth = ctx.measureText(line).width;
                const totalWidth = isLastLine ? textWidth + (emojisWidth > 0 ? emojisWidth + 5 : 0) : textWidth;
                let currentX = x - totalWidth / 2;
                
                ctx.font = '16px Inter, sans-serif';
                ctx.fillText(line, currentX + textWidth / 2, startY + index * 20);
                
                if (isLastLine && emojisWidth > 0) {
                    currentX += textWidth + 5;
                    ctx.font = `${EMOJI_FONT_SIZE}px Inter, sans-serif`;
                    ctx.fillText(emojisText, currentX + emojisWidth / 2, startY + index * 20);
                }
            });
            
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            if (nodes.some(n => n.parentId === node.id)) drawCollapseButton(node);
            if (appData.notes[node.id] && appData.notes[node.id].replace(/<[^>]*>/g, '').trim() !== '') drawNoteIcon(node);
        }
        
        function getCollapseButtonPosition(node) {
            return { x: node.x + node.width / 2, y: node.y };
        }

        function drawCollapseButton(node) {
            const pos = getCollapseButtonPosition(node);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 8, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.strokeStyle = '#9ca3af';
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(pos.x - 4, pos.y);
            ctx.lineTo(pos.x + 4, pos.y);
            if (node.isCollapsed) {
                ctx.moveTo(pos.x, pos.y - 4);
                ctx.lineTo(pos.x, pos.y + 4);
            }
            ctx.strokeStyle = '#3f3f46';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        function drawNoteIcon(node) {
            const x = node.x + node.width / 2 - 15;
            const y = node.y - node.height / 2 + 15;
            
            ctx.save();
            ctx.shadowColor = 'transparent';
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#0f0';
            ctx.fill();
            ctx.strokeStyle = '#4f5051';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();
        }

        function toggleCollapse(nodeId) {
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
                node.isCollapsed = !node.isCollapsed;
                applyTreeLayout();
                saveState();
            }
        }

        function isNodeHidden(nodeId) {
            let node = nodes.find(n => n.id === nodeId);
            while (node && node.parentId) {
                const parent = nodes.find(p => p.id === node.parentId);
                if (parent && parent.isCollapsed) return true;
                node = parent;
            }
            return false;
        }

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            redrawCanvas();
        }

        function formatDoc(command, value) {
            document.execCommand(command, false, value);
            noteContentDiv.focus();
        }
        
        function setupResizing() {
            const resizeHandle = document.getElementById('resizeHandle');
            let isResizing = false;

            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                let newWidth = window.innerWidth - e.clientX;
                
                const minWidth = window.innerWidth * 0.2;
                const maxWidth = window.innerWidth * 0.8;

                if (newWidth < minWidth) newWidth = minWidth;
                if (newWidth > maxWidth) newWidth = maxWidth;

                notesEditor.style.width = `${newWidth}px`;
                resizeHandle.style.right = `${newWidth}px`;
            });

            document.addEventListener('mouseup', () => {
                isResizing = false;
                document.body.style.cursor = 'default';
                document.body.style.userSelect = 'auto';
            });
        }

        function editNode(node) {
            editingNode = node;
            const canvasRect = canvas.getBoundingClientRect();
            const x = (node.x - node.width / 2) * scale + originX + canvasRect.left;
            const y = (node.y - node.height / 2) * scale + originY + canvasRect.top;
            
            // Define a cor de fundo do campo de edição para a cor do nó
            nodeEditorInput.style.backgroundColor = node.color;

            Object.assign(nodeEditorInput.style, {
                display: 'block',
                left: `${x}px`,
                top: `${y}px`,
                width: `${node.width * scale}px`,
                height: `${node.height * scale}px`,
                fontSize: `${16 * scale}px`
            });
            nodeEditorInput.value = node.text;
            nodeEditorInput.focus();
            redrawCanvas();
        }

        function finishEditingNode() {
            if (editingNode) {
                editingNode.text = nodeEditorInput.value;
                updateNodeAndRedraw(editingNode);
                editingNode = null;
                // Reseta o estilo do campo de edição
                nodeEditorInput.style.display = 'none';
                nodeEditorInput.style.backgroundColor = 'transparent';
            }
        }

        nodeEditorInput.addEventListener('blur', finishEditingNode);
        nodeEditorInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') finishEditingNode();
        });

        window.onload = init;
    </script>
</body>
</html>
